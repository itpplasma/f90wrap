! Fortran support module for direct C wrappers
! Auto-generated by f90wrap

module f90wrap__dtypes_support

    use mytype_mod
    use othertype_mod
    use iso_c_binding
    implicit none

contains

    subroutine f90wrap_mytype__allocate(ptr) bind(C, name='__mytype_mod_MOD_f90wrap_mytype__allocate')
        type(c_ptr), intent(out) :: ptr
        type(mytype), pointer :: fptr

        allocate(fptr)
        ptr = c_loc(fptr)
    end subroutine f90wrap_mytype__allocate

    subroutine f90wrap_mytype__deallocate(ptr) bind(C, name='__mytype_mod_MOD_f90wrap_mytype__deallocate')
        type(c_ptr), intent(inout) :: ptr
        type(mytype), pointer :: fptr

        if (c_associated(ptr)) then
            call c_f_pointer(ptr, fptr)
            deallocate(fptr)
            ptr = c_null_ptr
        end if
    end subroutine f90wrap_mytype__deallocate

    subroutine mytype_initialise(self, this) bind(C, name='__mytype_mod_MOD_mytype_initialise')
        type(c_ptr), value :: self
        type(c_ptr), intent(out) :: this

        ! Default initialization (Fortran handles this automatically)
        ! Just return the same pointer
        this = self
    end subroutine mytype_initialise

    subroutine mytype_finalise(self, this) bind(C, name='__mytype_mod_MOD_mytype_finalise')
        type(c_ptr), value :: self
        type(c_ptr), intent(inout) :: this

        ! Default finalization (cleanup happens at deallocation)
        ! Return the same pointer
        this = self
    end subroutine mytype_finalise

    subroutine f90wrap_mytype__get__a(self_ptr, value) bind(C, name='__mytype_mod_MOD_f90wrap_mytype__get__a')
        type(c_ptr), value :: self_ptr
        integer , intent(out) :: value
        type(mytype), pointer :: self

        call c_f_pointer(self_ptr, self)
        value = self%a
    end subroutine f90wrap_mytype__get__a

    subroutine f90wrap_mytype__set__a(self_ptr, value) bind(C, name='__mytype_mod_MOD_f90wrap_mytype__set__a')
        type(c_ptr), value :: self_ptr
        integer , intent(in) :: value
        type(mytype), pointer :: self

        call c_f_pointer(self_ptr, self)
        self%a = value
    end subroutine f90wrap_mytype__set__a

    subroutine f90wrap_othertype__allocate(ptr) bind(C, name='__othertype_mod_MOD_f90wrap_othertype__allocate')
        type(c_ptr), intent(out) :: ptr
        type(othertype), pointer :: fptr

        allocate(fptr)
        ptr = c_loc(fptr)
    end subroutine f90wrap_othertype__allocate

    subroutine f90wrap_othertype__deallocate(ptr) bind(C, name='__othertype_mod_MOD_f90wrap_othertype__deallocate')
        type(c_ptr), intent(inout) :: ptr
        type(othertype), pointer :: fptr

        if (c_associated(ptr)) then
            call c_f_pointer(ptr, fptr)
            deallocate(fptr)
            ptr = c_null_ptr
        end if
    end subroutine f90wrap_othertype__deallocate

    subroutine othertype_initialise(self, this) bind(C, name='__othertype_mod_MOD_othertype_initialise')
        type(c_ptr), value :: self
        type(c_ptr), intent(out) :: this

        ! Default initialization (Fortran handles this automatically)
        ! Just return the same pointer
        this = self
    end subroutine othertype_initialise

    subroutine othertype_finalise(self, this) bind(C, name='__othertype_mod_MOD_othertype_finalise')
        type(c_ptr), value :: self
        type(c_ptr), intent(inout) :: this

        ! Default finalization (cleanup happens at deallocation)
        ! Return the same pointer
        this = self
    end subroutine othertype_finalise

    subroutine f90wrap_othertype__get__a(self_ptr, value) bind(C, name='__othertype_mod_MOD_f90wrap_othertype__get__a')
        type(c_ptr), value :: self_ptr
        integer , intent(out) :: value
        type(othertype), pointer :: self

        call c_f_pointer(self_ptr, self)
        value = self%a
    end subroutine f90wrap_othertype__get__a

    subroutine f90wrap_othertype__set__a(self_ptr, value) bind(C, name='__othertype_mod_MOD_f90wrap_othertype__set__a')
        type(c_ptr), value :: self_ptr
        integer , intent(in) :: value
        type(othertype), pointer :: self

        call c_f_pointer(self_ptr, self)
        self%a = value
    end subroutine f90wrap_othertype__set__a

end module f90wrap__dtypes_support
