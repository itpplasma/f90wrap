{
  "generated": "2025-10-05T16:19:21.643487",
  "summary": {
    "total": 50,
    "passed": 30,
    "failed": 19,
    "skipped": 1,
    "pass_rate": "60.0%"
  },
  "error_categories": {
    "linking_failed": [
      "arrayderivedtypes",
      "derivedtypes"
    ],
    "fortran_compilation_failed": [
      "arrays",
      "cylinder",
      "derived-type-aliases",
      "errorbinding",
      "fortran_oo",
      "issue235_allocatable_classes",
      "issue254_getter",
      "issue258_derived_type_attributes",
      "issue41_abstract_classes",
      "keyword_renaming_issue160",
      "long_subroutine_name",
      "mod_arg_clash",
      "optional_derived_arrays",
      "type_bn"
    ],
    "c_compilation_failed": [
      "docstring",
      "optional_string"
    ],
    "attribute_error": [
      "fixed_1D_derived_type_array_argument"
    ]
  },
  "results": [
    {
      "name": "arrayderivedtypes",
      "path": "/home/ert/code/f90wrap/examples/arrayderivedtypes",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmphib_0iy8/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmphib_0iy8/test.fpp\nINFO:f90wrap.parser:parser reading type type_ptmes\nDEBUG:f90wrap.parser:    type type_ptmes\nINFO:f90wrap.parser:parser reading type array_type\nDEBUG:f90wrap.parser:    type array_type\nDEBUG:f90wrap.parser:    module subroutine checking recup_point\nDEBUG:f90wrap.parser:    module subroutine recup_point\nDEBUG:f90wrap.parser:  module module_calcul\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type type_ptmes defined in module module_calcul\nDEBUG:f90wrap.fortran:type array_type defined in module module_calcul\nDerived types detected in Fortran source files:\n{'array_type': Type(name=array_type),\n 'class(array_type)': Type(name=array_type),\n 'class(type_ptmes)': Type(name=type_ptmes),\n 'type(array_type)': Type(name=array_type),\n 'type(type_ptmes)': Type(name=type_ptmes),\n 'type_ptmes': Type(name=type_ptmes)}\n\nClass name mapping:\n{'array_type': 'array_type',\n 'class(array_type)': 'array_type',\n 'class(type_ptmes)': 'type_ptmes',\n 'type(array_type)': 'array_type',\n 'type(type_ptmes)': 'type_ptmes',\n 'type_ptmes': 'type_ptmes'}\nModules for each type:\n{'module_calcul': 'module_calcul'}\nDEBUG:f90wrap.fortran:type type_ptmes defined in module module_calcul\nDEBUG:f90wrap.fortran:type array_type defined in module module_calcul\nDEBUG:f90wrap.transform:marking public symbol type_ptmes\nDEBUG:f90wrap.transform:marking public symbol array_type\nDEBUG:f90wrap.transform:marking public symbol xarr\nDEBUG:f90wrap.transform:marking public symbol recup_point\nDEBUG:f90wrap.transform:visiting Module(name=module_calcul)\nDEBUG:f90wrap.transform:visiting Type(name=type_ptmes)\nDEBUG:f90wrap.transform:visiting Type(name=array_type)\nINFO:f90wrap.transform:adding missing constructor for type_ptmes\nINFO:f90wrap.transform:adding missing constructor for array_type\nINFO:f90wrap.transform:adding missing destructor for type_ptmes\nINFO:f90wrap.transform:adding missing destructor for array_type\nDEBUG:f90wrap.transform:visiting Module(name=module_calcul)\nINFO:f90wrap.transform:visiting Module(name=module_calcul) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=type_ptmes)\nINFO:f90wrap.transform:visiting Type(name=type_ptmes) found 1 constructors with names: ['type_ptmes_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=array_type)\nINFO:f90wrap.transform:visiting Type(name=array_type) found 1 constructors with names: ['array_type_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in type_ptmes_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in type_ptmes_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in array_type_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in array_type_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _arrayderivedtypes_directmodule.c\nINFO:root:Generated Fortran support module: arrayderivedtypes_direct_support.f90\nINFO:root:Generated minimal Python wrapper: arrayderivedtypes_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "linking_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m arrayderivedtypes_direct /tmp/tmphib_0iy8/test.fpp -k /tmp/tmphib_0iy8/kind_map --direct-c -v",
        "Generated C files: ['_arrayderivedtypes_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Found support module: arrayderivedtypes_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90 arrayderivedtypes_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _arrayderivedtypes_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _arrayderivedtypes_directmodule.o",
        "Linking: gcc -shared _arrayderivedtypes_directmodule.o arrayderivedtypes_direct_support.o test_processed.o test.o -lgfortran -o _arrayderivedtypes_direct.so",
        "Linking failed: /usr/bin/ld: test.o:(.bss+0x0): multiple definition of `__module_calcul_MOD___def_init_module_calcul_Array_type'; test_processed.o:(.bss+0x0): first defined here\n/usr/bin/ld: test.o:(.bss+0x8): multiple definition of `__module_calcul_MOD___def_init_module_calcul_Type_ptmes'; test_processed.o:(.bss+0x8): first defined here\n/usr/bin/ld: test.o:(.data.rel+0x0): multiple definition of `__module_calcul_MOD___vtab_module_calcul_Array_type'; test_processed.o:(.data.rel+0x0): first defined here\n/usr/bin"
      ]
    },
    {
      "name": "arrays",
      "path": "/home/ert/code/f90wrap/examples/arrays",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpapn9cvf_/library.fpp', '/tmp/tmpapn9cvf_/parameters.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpapn9cvf_/library.fpp\nINFO:f90wrap.parser:marking module library as default private\nDEBUG:f90wrap.parser:    module subroutine checking do_array_stuff\nDEBUG:f90wrap.parser:    module subroutine do_array_stuff\nDEBUG:f90wrap.parser:    module subroutine checking only_manipulate\nDEBUG:f90wrap.parser:    module subroutine only_manipulate\nDEBUG:f90wrap.parser:    module subroutine checking return_array\nDEBUG:f90wrap.parser:    module subroutine return_array\nDEBUG:f90wrap.parser:  module library\nDEBUG:f90wrap.parser:processing file /tmp/tmpapn9cvf_/parameters.fpp\nINFO:f90wrap.parser:marking module parameters as default private\nDEBUG:f90wrap.parser:    module subroutine checking do_array_stuff\nDEBUG:f90wrap.parser:    module subroutine do_array_stuff\nDEBUG:f90wrap.parser:  module parameters\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking private symbol do_array_stuff\nDEBUG:f90wrap.transform:removing private symbol do_array_stuff\nDEBUG:f90wrap.transform:visiting Module(name=library)\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nDEBUG:f90wrap.transform:visiting Module(name=library)\nINFO:f90wrap.transform:visiting Module(name=library) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nINFO:f90wrap.transform:visiting Module(name=parameters) found 0 constructors with names: []\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to return_array\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n3)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to only_manipulate\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _arrays_directmodule.c\nINFO:root:Generated minimal Python wrapper: arrays_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['library.fpp', 'parameters.fpp']",
        "Command: f90wrap -m arrays_direct /tmp/tmpapn9cvf_/library.fpp /tmp/tmpapn9cvf_/parameters.fpp -k /tmp/tmpapn9cvf_/kind_map --direct-c -v",
        "Generated C files: ['_arrays_directmodule.c']",
        "Preprocessed library.fpp -> library_processed.f90",
        "Preprocessed parameters.fpp -> parameters_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c library_processed.f90 parameters_processed.f90",
        "Fortran compilation failed: /home/ert/code/f90wrap/examples/arrays/library.f90:3:9:\n\n    3 |     use parameters, only: idp, isp\n      |         1\nFatal Error: Cannot open module file \u2018parameters.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\n"
      ]
    },
    {
      "name": "arrays_fixed",
      "path": "/home/ert/code/f90wrap/examples/arrays_fixed",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmphdw6ut4x/parameters.f', '/tmp/tmphdw6ut4x/library.f'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmphdw6ut4x/parameters.f\nINFO:f90wrap.parser:marking module parameters as default private\nDEBUG:f90wrap.parser:  module parameters\nDEBUG:f90wrap.parser:processing file /tmp/tmphdw6ut4x/library.f\nINFO:f90wrap.parser:marking module library as default private\nDEBUG:f90wrap.parser:    module subroutine checking do_array_stuff\nDEBUG:f90wrap.parser:    module subroutine do_array_stuff\nDEBUG:f90wrap.parser:    module subroutine checking only_manipulate\nDEBUG:f90wrap.parser:    module subroutine only_manipulate\nDEBUG:f90wrap.parser:    module subroutine checking return_array\nDEBUG:f90wrap.parser:    module subroutine return_array\nDEBUG:f90wrap.parser:  module library\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nDEBUG:f90wrap.transform:visiting Module(name=library)\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nINFO:f90wrap.transform:visiting Module(name=parameters) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Module(name=library)\nINFO:f90wrap.transform:visiting Module(name=library) found 0 constructors with names: []\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n3)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to return_array\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to only_manipulate\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _arrays_fixed_directmodule.c\nINFO:root:Generated minimal Python wrapper: arrays_fixed_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using source files for f90wrap: ['parameters.f', 'library.f']",
        "Command: f90wrap -m arrays_fixed_direct /tmp/tmphdw6ut4x/parameters.f /tmp/tmphdw6ut4x/library.f -k /tmp/tmphdw6ut4x/kind_map --direct-c -v",
        "Generated C files: ['_arrays_fixed_directmodule.c']",
        "Compiling Fortran: gfortran -fPIC -c parameters.f library.f",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _arrays_fixed_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _arrays_fixed_directmodule.o",
        "Linking: gcc -shared _arrays_fixed_directmodule.o library.o parameters.o -lgfortran -o _arrays_fixed_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "arrays_in_derived_types_issue50",
      "path": "/home/ert/code/f90wrap/examples/arrays_in_derived_types_issue50",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dp': 'double',\n          'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp71el5c6r/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp71el5c6r/test.fpp\nINFO:f90wrap.parser:parser reading type real_array\nDEBUG:f90wrap.parser:    type real_array\nDEBUG:f90wrap.parser:    module subroutine checking testf\nDEBUG:f90wrap.parser:    module subroutine testf\nDEBUG:f90wrap.parser:  module module_test\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type real_array defined in module module_test\nDerived types detected in Fortran source files:\n{'class(real_array)': Type(name=real_array),\n 'real_array': Type(name=real_array),\n 'type(real_array)': Type(name=real_array)}\n\nClass name mapping:\n{'class(real_array)': 'real_array',\n 'real_array': 'real_array',\n 'type(real_array)': 'real_array'}\nModules for each type:\n{'module_test': 'module_test'}\nDEBUG:f90wrap.fortran:type real_array defined in module module_test\nDEBUG:f90wrap.transform:marking public symbol real_array\nDEBUG:f90wrap.transform:marking public symbol testf\nDEBUG:f90wrap.transform:visiting Module(name=module_test)\nDEBUG:f90wrap.transform:visiting Type(name=real_array)\nINFO:f90wrap.transform:adding missing constructor for real_array\nINFO:f90wrap.transform:adding missing destructor for real_array\nDEBUG:f90wrap.transform:visiting Module(name=module_test)\nINFO:f90wrap.transform:visiting Module(name=module_test) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=real_array)\nINFO:f90wrap.transform:visiting Type(name=real_array) found 1 constructors with names: ['real_array_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in real_array_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in real_array_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _arrays_in_derived_types_issue50_directmodule.c\nINFO:root:Generated Fortran support module: arrays_in_derived_types_issue50_direct_support.f90\nINFO:root:Generated minimal Python wrapper: arrays_in_derived_types_issue50_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m arrays_in_derived_types_issue50_direct /tmp/tmp71el5c6r/test.fpp -k /tmp/tmp71el5c6r/kind_map --direct-c -v",
        "Generated C files: ['_arrays_in_derived_types_issue50_directmodule.c', '_test_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Found support module: arrays_in_derived_types_issue50_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90 arrays_in_derived_types_issue50_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _arrays_in_derived_types_issue50_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _arrays_in_derived_types_issue50_directmodule.o",
        "Compiling C: gcc -fPIC -c _test_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _test_directmodule.o",
        "Linking: gcc -shared _test_directmodule.o _arrays_in_derived_types_issue50_directmodule.o arrays_in_derived_types_issue50_direct_support.o test_processed.o -lgfortran -o _arrays_in_derived_types_issue50_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "auto_raise_error",
      "path": "/home/ert/code/f90wrap/examples/auto_raise_error",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpv7j751m5/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpv7j751m5/main.fpp\nINFO:f90wrap.parser:marking module m_error as default private\nDEBUG:f90wrap.parser:    module subroutine checking auto_raise\nDEBUG:f90wrap.parser:    module subroutine auto_raise\nDEBUG:f90wrap.parser:    module subroutine checking auto_raise_optional\nDEBUG:f90wrap.parser:    module subroutine auto_raise_optional\nDEBUG:f90wrap.parser:    module subroutine checking auto_no_raise\nDEBUG:f90wrap.parser:    module subroutine auto_no_raise\nDEBUG:f90wrap.parser:    module subroutine checking auto_no_raise_optional\nDEBUG:f90wrap.parser:    module subroutine auto_no_raise_optional\nDEBUG:f90wrap.parser:    module subroutine checking no_error_var\nDEBUG:f90wrap.parser:    module subroutine no_error_var\nDEBUG:f90wrap.parser:  module m_error\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:visiting Module(name=m_error)\nDEBUG:f90wrap.transform:visiting Module(name=m_error)\nINFO:f90wrap.transform:visiting Module(name=m_error) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _auto_raise_error_directmodule.c\nINFO:root:Generated minimal Python wrapper: auto_raise_error_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m auto_raise_error_direct /tmp/tmpv7j751m5/main.fpp  --direct-c -v",
        "Generated C files: ['_auto_raise_error_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _auto_raise_error_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _auto_raise_error_directmodule.o",
        "Linking: gcc -shared _auto_raise_error_directmodule.o main_processed.o -lgfortran -o _auto_raise_error_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "callback_print_function_issue93",
      "path": "/home/ert/code/f90wrap/examples/callback_print_function_issue93",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpwbdj8vny/cback.fpp', '/tmp/tmpwbdj8vny/caller.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpwbdj8vny/cback.fpp\nINFO:f90wrap.parser:marking module cback as default public\nDEBUG:f90wrap.parser:    module subroutine checking write_message\nDEBUG:f90wrap.parser:    module subroutine write_message\nDEBUG:f90wrap.parser:  module cback\nDEBUG:f90wrap.parser:processing file /tmp/tmpwbdj8vny/caller.fpp\nINFO:f90wrap.parser:marking module caller as default public\nDEBUG:f90wrap.parser:    module subroutine checking test_write_msg\nDEBUG:f90wrap.parser:    module subroutine test_write_msg\nDEBUG:f90wrap.parser:    module subroutine checking test_write_msg_2\nDEBUG:f90wrap.parser:    module subroutine test_write_msg_2\nDEBUG:f90wrap.parser:  module caller\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking public symbol write_message\nDEBUG:f90wrap.transform:marking public symbol test_write_msg\nDEBUG:f90wrap.transform:marking public symbol test_write_msg_2\nDEBUG:f90wrap.transform:visiting Module(name=cback)\nDEBUG:f90wrap.transform:visiting Module(name=caller)\nDEBUG:f90wrap.transform:visiting Module(name=cback)\nINFO:f90wrap.transform:visiting Module(name=cback) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Module(name=caller)\nINFO:f90wrap.transform:visiting Module(name=caller) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _callback_print_function_issue93_directmodule.c\nINFO:root:Generated minimal Python wrapper: callback_print_function_issue93_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['cback.fpp', 'caller.fpp']",
        "Command: f90wrap -m callback_print_function_issue93_direct /tmp/tmpwbdj8vny/cback.fpp /tmp/tmpwbdj8vny/caller.fpp -k /tmp/tmpwbdj8vny/kind_map --direct-c -v",
        "Generated C files: ['_callback_print_function_issue93_directmodule.c']",
        "Preprocessed cback.fpp -> cback_processed.f90",
        "Preprocessed caller.fpp -> caller_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c cback_processed.f90 caller_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _callback_print_function_issue93_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _callback_print_function_issue93_directmodule.o",
        "Linking: gcc -shared _callback_print_function_issue93_directmodule.o caller_processed.o cback_processed.o -lgfortran -o _callback_print_function_issue93_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "class_names",
      "path": "/home/ert/code/f90wrap/examples/class_names",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpqn17pywe/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpqn17pywe/test.fpp\nINFO:f90wrap.parser:parser reading type ceci_ne_pas_un_chameau\nDEBUG:f90wrap.parser:    type ceci_ne_pas_un_chameau\nINFO:f90wrap.parser:parser reading type array_type\nDEBUG:f90wrap.parser:    type array_type\nDEBUG:f90wrap.parser:    module subroutine checking recup_point\nDEBUG:f90wrap.parser:    module subroutine recup_point\nDEBUG:f90wrap.parser:  module module_snake_mod\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type ceci_ne_pas_un_chameau defined in module module_snake_mod\nDEBUG:f90wrap.fortran:type array_type defined in module module_snake_mod\nDerived types detected in Fortran source files:\n{'array_type': Type(name=array_type),\n 'ceci_ne_pas_un_chameau': Type(name=ceci_ne_pas_un_chameau),\n 'class(array_type)': Type(name=array_type),\n 'class(ceci_ne_pas_un_chameau)': Type(name=ceci_ne_pas_un_chameau),\n 'type(array_type)': Type(name=array_type),\n 'type(ceci_ne_pas_un_chameau)': Type(name=ceci_ne_pas_un_chameau)}\n\nClass name mapping:\n{'array_type': 'array_type',\n 'ceci_ne_pas_un_chameau': 'ceci_ne_pas_un_chameau',\n 'class(array_type)': 'array_type',\n 'class(ceci_ne_pas_un_chameau)': 'ceci_ne_pas_un_chameau',\n 'type(array_type)': 'array_type',\n 'type(ceci_ne_pas_un_chameau)': 'ceci_ne_pas_un_chameau'}\nModules for each type:\n{'module_snake_mod': 'module_snake_mod'}\nDEBUG:f90wrap.fortran:type ceci_ne_pas_un_chameau defined in module module_snake_mod\nDEBUG:f90wrap.fortran:type array_type defined in module module_snake_mod\nDEBUG:f90wrap.transform:marking public symbol ceci_ne_pas_un_chameau\nDEBUG:f90wrap.transform:marking public symbol array_type\nDEBUG:f90wrap.transform:marking public symbol xarr\nDEBUG:f90wrap.transform:marking public symbol recup_point\nDEBUG:f90wrap.transform:visiting Module(name=module_snake_mod)\nDEBUG:f90wrap.transform:visiting Type(name=ceci_ne_pas_un_chameau)\nDEBUG:f90wrap.transform:visiting Type(name=array_type)\nINFO:f90wrap.transform:adding missing constructor for ceci_ne_pas_un_chameau\nINFO:f90wrap.transform:adding missing constructor for array_type\nINFO:f90wrap.transform:adding missing destructor for ceci_ne_pas_un_chameau\nINFO:f90wrap.transform:adding missing destructor for array_type\nDEBUG:f90wrap.transform:visiting Module(name=module_snake_mod)\nINFO:f90wrap.transform:visiting Module(name=module_snake_mod) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=ceci_ne_pas_un_chameau)\nINFO:f90wrap.transform:visiting Type(name=ceci_ne_pas_un_chameau) found 1 constructors with names: ['ceci_ne_pas_un_chameau_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=array_type)\nINFO:f90wrap.transform:visiting Type(name=array_type) found 1 constructors with names: ['array_type_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in ceci_ne_pas_un_chameau_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in ceci_ne_pas_un_chameau_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in array_type_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in array_type_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _class_names_directmodule.c\nINFO:root:Generated Fortran support module: class_names_direct_support.f90\nINFO:root:Generated minimal Python wrapper: class_names_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m class_names_direct /tmp/tmpqn17pywe/test.fpp -k /tmp/tmpqn17pywe/kind_map --direct-c -v",
        "Generated C files: ['_class_names_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Found support module: class_names_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90 class_names_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _class_names_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _class_names_directmodule.o",
        "Linking: gcc -shared _class_names_directmodule.o class_names_direct_support.o test_processed.o -lgfortran -o _class_names_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "cylinder",
      "path": "/home/ert/code/f90wrap/examples/cylinder",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char', '1': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'2': 'int', '4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dbl_ad': 'double',\n          'dp': 'double',\n          'idp': 'double',\n          'isp': 'float',\n          'sng_ad': 'float'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpmmzigjx2/cyldnad.fpp', '/tmp/tmpmmzigjx2/DNAD.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpmmzigjx2/cyldnad.fpp\nDEBUG:f90wrap.parser:    module subroutine checking cyldnad\nDEBUG:f90wrap.parser:    module subroutine cyldnad\nDEBUG:f90wrap.parser:  module mcyldnad\nDEBUG:f90wrap.parser:processing file /tmp/tmpmmzigjx2/DNAD.fpp\nINFO:f90wrap.parser:marking module Dual_Num_Auto_Diff as default private\nINFO:f90wrap.parser:parser reading type DUAL_NUM\nDEBUG:f90wrap.parser:    type DUAL_NUM\nDEBUG:f90wrap.parser:    interface ASSIGNMENT(=)\nDEBUG:f90wrap.parser:    interface OPERATOR(+)\nDEBUG:f90wrap.parser:    interface OPERATOR(-)\nDEBUG:f90wrap.parser:    interface OPERATOR(*)\nDEBUG:f90wrap.parser:    interface OPERATOR(/)\nDEBUG:f90wrap.parser:    interface OPERATOR(**)\nDEBUG:f90wrap.parser:    interface OPERATOR(==)\nDEBUG:f90wrap.parser:    interface OPERATOR(<=)\nDEBUG:f90wrap.parser:    interface OPERATOR(<)\nDEBUG:f90wrap.parser:    interface OPERATOR(>=)\nDEBUG:f90wrap.parser:    interface OPERATOR(>)\nDEBUG:f90wrap.parser:    interface OPERATOR(/=)\nDEBUG:f90wrap.parser:    interface ABS\nDEBUG:f90wrap.parser:    interface DABS\nDEBUG:f90wrap.parser:    interface ACOS\nDEBUG:f90wrap.parser:    interface ASIN\nDEBUG:f90wrap.parser:    interface COS\nDEBUG:f90wrap.parser:    interface DCOS\nDEBUG:f90wrap.parser:    interface DOT_PRODUCT\nDEBUG:f90wrap.parser:    interface EXP\nDEBUG:f90wrap.parser:    interface INT\nDEBUG:f90wrap.parser:    interface LOG\nDEBUG:f90wrap.parser:    interface LOG10\nDEBUG:f90wrap.parser:    interface MATMUL\nDEBUG:f90wrap.parser:    interface MAX\nDEBUG:f90wrap.parser:    interface DMAX1\nDEBUG:f90wrap.parser:    interface MAXVAL\nDEBUG:f90wrap.parser:    interface MIN\nDEBUG:f90wrap.parser:    interface DMIN1\nDEBUG:f90wrap.parser:    interface MINVAL\nDEBUG:f90wrap.parser:    interface NINT\nDEBUG:f90wrap.parser:    interface SIGN\nDEBUG:f90wrap.parser:    interface SIN\nDEBUG:f90wrap.parser:    interface DSIN\nDEBUG:f90wrap.parser:    interface SQRT\nDEBUG:f90wrap.parser:    interface SUM\nDEBUG:f90wrap.parser:    module subroutine checking ASSIGN_DI\nDEBUG:f90wrap.parser:    module subroutine ASSIGN_DI\nDEBUG:f90wrap.parser:    module subroutine checking ASSIGN_DR\nDEBUG:f90wrap.parser:    module subroutine ASSIGN_DR\nDEBUG:f90wrap.parser:    module subroutine checking ASSIGN_DS\nDEBUG:f90wrap.parser:    module subroutine ASSIGN_DS\nDEBUG:f90wrap.parser:    module subroutine checking ASSIGN_ID\nDEBUG:f90wrap.parser:    module subroutine ASSIGN_ID\nDEBUG:f90wrap.parser:    module function checking ADD_D\nDEBUG:f90wrap.parser:        implicit type of \"ADD_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_D\nDEBUG:f90wrap.parser:    module function checking ADD_DD\nDEBUG:f90wrap.parser:        implicit type of \"ADD_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_DD\nDEBUG:f90wrap.parser:    module function checking ADD_DI\nDEBUG:f90wrap.parser:        implicit type of \"ADD_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_DI\nDEBUG:f90wrap.parser:    module function checking ADD_DR\nDEBUG:f90wrap.parser:        implicit type of \"ADD_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_DR\nDEBUG:f90wrap.parser:    module function checking ADD_DS\nDEBUG:f90wrap.parser:        implicit type of \"ADD_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_DS\nDEBUG:f90wrap.parser:    module function checking ADD_ID\nDEBUG:f90wrap.parser:        implicit type of \"ADD_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_ID\nDEBUG:f90wrap.parser:    module function checking ADD_RD\nDEBUG:f90wrap.parser:        implicit type of \"ADD_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_RD\nDEBUG:f90wrap.parser:    module function checking ADD_SD\nDEBUG:f90wrap.parser:        implicit type of \"ADD_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ADD_SD\nDEBUG:f90wrap.parser:    module function checking MINUS_D\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_D\nDEBUG:f90wrap.parser:    module function checking MINUS_DD\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_DD\nDEBUG:f90wrap.parser:    module function checking MINUS_DI\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_DI\nDEBUG:f90wrap.parser:    module function checking MINUS_DR\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_DR\nDEBUG:f90wrap.parser:    module function checking MINUS_DS\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_DS\nDEBUG:f90wrap.parser:    module function checking MINUS_ID\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_ID\nDEBUG:f90wrap.parser:    module function checking MINUS_RD\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_RD\nDEBUG:f90wrap.parser:    module function checking MINUS_SD\nDEBUG:f90wrap.parser:        implicit type of \"MINUS_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINUS_SD\nDEBUG:f90wrap.parser:    module function checking MULT_DD\nDEBUG:f90wrap.parser:        implicit type of \"MULT_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MULT_DD\nDEBUG:f90wrap.parser:    module function checking MULT_DI\nDEBUG:f90wrap.parser:        implicit type of \"MULT_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MULT_DI\nDEBUG:f90wrap.parser:    module function checking MULT_DR\nDEBUG:f90wrap.parser:        implicit type of \"MULT_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MULT_DR\nDEBUG:f90wrap.parser:    module function checking MULT_DS\nDEBUG:f90wrap.parser:        implicit type of \"MULT_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MULT_DS\nDEBUG:f90wrap.parser:    module function checking MULT_ID\nDEBUG:f90wrap.parser:        implicit type of \"MULT_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MULT_ID\nDEBUG:f90wrap.parser:    module function checking MULT_RD\nDEBUG:f90wrap.parser:        implicit type of \"MULT_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MULT_RD\nDEBUG:f90wrap.parser:    module function checking MULT_SD\nDEBUG:f90wrap.parser:        implicit type of \"MULT_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MULT_SD\nDEBUG:f90wrap.parser:    module function checking DIV_DD\nDEBUG:f90wrap.parser:        implicit type of \"DIV_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DIV_DD\nDEBUG:f90wrap.parser:    module function checking DIV_DI\nDEBUG:f90wrap.parser:        implicit type of \"DIV_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DIV_DI\nDEBUG:f90wrap.parser:    module function checking DIV_DR\nDEBUG:f90wrap.parser:        implicit type of \"DIV_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DIV_DR\nDEBUG:f90wrap.parser:    module function checking DIV_DS\nDEBUG:f90wrap.parser:        implicit type of \"DIV_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DIV_DS\nDEBUG:f90wrap.parser:    module function checking DIV_ID\nDEBUG:f90wrap.parser:        implicit type of \"DIV_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DIV_ID\nDEBUG:f90wrap.parser:    module function checking DIV_RD\nDEBUG:f90wrap.parser:        implicit type of \"DIV_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DIV_RD\nDEBUG:f90wrap.parser:    module function checking DIV_SD\nDEBUG:f90wrap.parser:        implicit type of \"DIV_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DIV_SD\nDEBUG:f90wrap.parser:    module function checking POW_I\nDEBUG:f90wrap.parser:        implicit type of \"POW_I\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function POW_I\nDEBUG:f90wrap.parser:    module function checking POW_R\nDEBUG:f90wrap.parser:        implicit type of \"POW_R\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function POW_R\nDEBUG:f90wrap.parser:    module function checking POW_S\nDEBUG:f90wrap.parser:        implicit type of \"POW_S\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function POW_S\nDEBUG:f90wrap.parser:    module function checking POW_D\nDEBUG:f90wrap.parser:        implicit type of \"POW_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function POW_D\nDEBUG:f90wrap.parser:    module function checking EQ_DD\nDEBUG:f90wrap.parser:        implicit type of \"EQ_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EQ_DD\nDEBUG:f90wrap.parser:    module function checking EQ_DI\nDEBUG:f90wrap.parser:        implicit type of \"EQ_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EQ_DI\nDEBUG:f90wrap.parser:    module function checking EQ_DR\nDEBUG:f90wrap.parser:        implicit type of \"EQ_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EQ_DR\nDEBUG:f90wrap.parser:    module function checking EQ_DS\nDEBUG:f90wrap.parser:        implicit type of \"EQ_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EQ_DS\nDEBUG:f90wrap.parser:    module function checking EQ_ID\nDEBUG:f90wrap.parser:        implicit type of \"EQ_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EQ_ID\nDEBUG:f90wrap.parser:    module function checking EQ_RD\nDEBUG:f90wrap.parser:        implicit type of \"EQ_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EQ_RD\nDEBUG:f90wrap.parser:    module function checking EQ_SD\nDEBUG:f90wrap.parser:        implicit type of \"EQ_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EQ_SD\nDEBUG:f90wrap.parser:    module function checking LE_DD\nDEBUG:f90wrap.parser:        implicit type of \"LE_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LE_DD\nDEBUG:f90wrap.parser:    module function checking LE_DI\nDEBUG:f90wrap.parser:        implicit type of \"LE_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LE_DI\nDEBUG:f90wrap.parser:    module function checking LE_DR\nDEBUG:f90wrap.parser:        implicit type of \"LE_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LE_DR\nDEBUG:f90wrap.parser:    module function checking LE_DS\nDEBUG:f90wrap.parser:        implicit type of \"LE_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LE_DS\nDEBUG:f90wrap.parser:    module function checking LE_ID\nDEBUG:f90wrap.parser:        implicit type of \"LE_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LE_ID\nDEBUG:f90wrap.parser:    module function checking LE_RD\nDEBUG:f90wrap.parser:        implicit type of \"LE_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LE_RD\nDEBUG:f90wrap.parser:    module function checking LE_SD\nDEBUG:f90wrap.parser:        implicit type of \"LE_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LE_SD\nDEBUG:f90wrap.parser:    module function checking LT_DD\nDEBUG:f90wrap.parser:        implicit type of \"LT_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LT_DD\nDEBUG:f90wrap.parser:    module function checking LT_DI\nDEBUG:f90wrap.parser:        implicit type of \"LT_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LT_DI\nDEBUG:f90wrap.parser:    module function checking LT_DR\nDEBUG:f90wrap.parser:        implicit type of \"LT_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LT_DR\nDEBUG:f90wrap.parser:    module function checking LT_DS\nDEBUG:f90wrap.parser:        implicit type of \"LT_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LT_DS\nDEBUG:f90wrap.parser:    module function checking LT_ID\nDEBUG:f90wrap.parser:        implicit type of \"LT_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LT_ID\nDEBUG:f90wrap.parser:    module function checking LT_RD\nDEBUG:f90wrap.parser:        implicit type of \"LT_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LT_RD\nDEBUG:f90wrap.parser:    module function checking LT_SD\nDEBUG:f90wrap.parser:        implicit type of \"LT_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LT_SD\nDEBUG:f90wrap.parser:    module function checking GE_DD\nDEBUG:f90wrap.parser:        implicit type of \"GE_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GE_DD\nDEBUG:f90wrap.parser:    module function checking GE_DI\nDEBUG:f90wrap.parser:        implicit type of \"GE_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GE_DI\nDEBUG:f90wrap.parser:    module function checking GE_DR\nDEBUG:f90wrap.parser:        implicit type of \"GE_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GE_DR\nDEBUG:f90wrap.parser:    module function checking GE_DS\nDEBUG:f90wrap.parser:        implicit type of \"GE_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GE_DS\nDEBUG:f90wrap.parser:    module function checking GE_ID\nDEBUG:f90wrap.parser:        implicit type of \"GE_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GE_ID\nDEBUG:f90wrap.parser:    module function checking GE_RD\nDEBUG:f90wrap.parser:        implicit type of \"GE_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GE_RD\nDEBUG:f90wrap.parser:    module function checking GE_SD\nDEBUG:f90wrap.parser:        implicit type of \"GE_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GE_SD\nDEBUG:f90wrap.parser:    module function checking GT_DD\nDEBUG:f90wrap.parser:        implicit type of \"GT_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GT_DD\nDEBUG:f90wrap.parser:    module function checking GT_DI\nDEBUG:f90wrap.parser:        implicit type of \"GT_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GT_DI\nDEBUG:f90wrap.parser:    module function checking GT_DR\nDEBUG:f90wrap.parser:        implicit type of \"GT_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GT_DR\nDEBUG:f90wrap.parser:    module function checking GT_DS\nDEBUG:f90wrap.parser:        implicit type of \"GT_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GT_DS\nDEBUG:f90wrap.parser:    module function checking GT_ID\nDEBUG:f90wrap.parser:        implicit type of \"GT_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GT_ID\nDEBUG:f90wrap.parser:    module function checking GT_RD\nDEBUG:f90wrap.parser:        implicit type of \"GT_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GT_RD\nDEBUG:f90wrap.parser:    module function checking GT_SD\nDEBUG:f90wrap.parser:        implicit type of \"GT_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function GT_SD\nDEBUG:f90wrap.parser:    module function checking NE_DD\nDEBUG:f90wrap.parser:        implicit type of \"NE_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NE_DD\nDEBUG:f90wrap.parser:    module function checking NE_DI\nDEBUG:f90wrap.parser:        implicit type of \"NE_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NE_DI\nDEBUG:f90wrap.parser:    module function checking NE_DR\nDEBUG:f90wrap.parser:        implicit type of \"NE_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NE_DR\nDEBUG:f90wrap.parser:    module function checking NE_DS\nDEBUG:f90wrap.parser:        implicit type of \"NE_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NE_DS\nDEBUG:f90wrap.parser:    module function checking NE_ID\nDEBUG:f90wrap.parser:        implicit type of \"NE_ID\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NE_ID\nDEBUG:f90wrap.parser:    module function checking NE_RD\nDEBUG:f90wrap.parser:        implicit type of \"NE_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NE_RD\nDEBUG:f90wrap.parser:    module function checking NE_SD\nDEBUG:f90wrap.parser:        implicit type of \"NE_SD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NE_SD\nDEBUG:f90wrap.parser:    module function checking ABS_D\nDEBUG:f90wrap.parser:        implicit type of \"ABS_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ABS_D\nDEBUG:f90wrap.parser:    module function checking ACOS_D\nDEBUG:f90wrap.parser:        implicit type of \"ACOS_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ACOS_D\nDEBUG:f90wrap.parser:    module function checking ASIN_D\nDEBUG:f90wrap.parser:        implicit type of \"ASIN_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ASIN_D\nDEBUG:f90wrap.parser:    module function checking COS_D\nDEBUG:f90wrap.parser:        implicit type of \"COS_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function COS_D\nDEBUG:f90wrap.parser:    module function checking DOT_PRODUCT_DD\nDEBUG:f90wrap.parser:        implicit type of \"DOT_PRODUCT_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function DOT_PRODUCT_DD\nDEBUG:f90wrap.parser:    module function checking EXP_D\nDEBUG:f90wrap.parser:        implicit type of \"EXP_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function EXP_D\nDEBUG:f90wrap.parser:    module function checking INT_D\nDEBUG:f90wrap.parser:        implicit type of \"INT_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function INT_D\nDEBUG:f90wrap.parser:    module function checking LOG_D\nDEBUG:f90wrap.parser:        implicit type of \"LOG_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LOG_D\nDEBUG:f90wrap.parser:    module function checking LOG10_D\nDEBUG:f90wrap.parser:        implicit type of \"LOG10_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function LOG10_D\nDEBUG:f90wrap.parser:    module function checking MATMUL_DD\nDEBUG:f90wrap.parser:        implicit type of \"MATMUL_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MATMUL_DD\nDEBUG:f90wrap.parser:    module function checking MATMUL_DV\nDEBUG:f90wrap.parser:        implicit type of \"MATMUL_DV\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MATMUL_DV\nDEBUG:f90wrap.parser:    module function checking MATMUL_VD\nDEBUG:f90wrap.parser:        implicit type of \"MATMUL_VD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MATMUL_VD\nDEBUG:f90wrap.parser:    module function checking MAX_DD\nDEBUG:f90wrap.parser:        implicit type of \"MAX_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MAX_DD\nDEBUG:f90wrap.parser:    module function checking MAX_DI\nDEBUG:f90wrap.parser:        implicit type of \"MAX_DI\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MAX_DI\nDEBUG:f90wrap.parser:    module function checking MAX_DR\nDEBUG:f90wrap.parser:        implicit type of \"MAX_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MAX_DR\nDEBUG:f90wrap.parser:    module function checking MAX_DS\nDEBUG:f90wrap.parser:        implicit type of \"MAX_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MAX_DS\nDEBUG:f90wrap.parser:    module function checking MAX_RD\nDEBUG:f90wrap.parser:        implicit type of \"MAX_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MAX_RD\nDEBUG:f90wrap.parser:    module function checking MAXVAL_D\nDEBUG:f90wrap.parser:        implicit type of \"MAXVAL_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MAXVAL_D\nDEBUG:f90wrap.parser:    module function checking MIN_DD\nDEBUG:f90wrap.parser:        implicit type of \"MIN_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MIN_DD\nDEBUG:f90wrap.parser:    module function checking MIN_DR\nDEBUG:f90wrap.parser:        implicit type of \"MIN_DR\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MIN_DR\nDEBUG:f90wrap.parser:    module function checking MIN_DS\nDEBUG:f90wrap.parser:        implicit type of \"MIN_DS\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MIN_DS\nDEBUG:f90wrap.parser:    module function checking MINVAL_D\nDEBUG:f90wrap.parser:        implicit type of \"MINVAL_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function MINVAL_D\nDEBUG:f90wrap.parser:    module function checking NINT_D\nDEBUG:f90wrap.parser:        implicit type of \"NINT_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function NINT_D\nDEBUG:f90wrap.parser:    module function checking SIGN_DD\nDEBUG:f90wrap.parser:        implicit type of \"SIGN_DD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function SIGN_DD\nDEBUG:f90wrap.parser:    module function checking SIGN_RD\nDEBUG:f90wrap.parser:        implicit type of \"SIGN_RD\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function SIGN_RD\nDEBUG:f90wrap.parser:    module function checking SIN_D\nDEBUG:f90wrap.parser:        implicit type of \"SIN_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function SIN_D\nDEBUG:f90wrap.parser:    module function checking SQRT_D\nDEBUG:f90wrap.parser:        implicit type of \"SQRT_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function SQRT_D\nDEBUG:f90wrap.parser:    module function checking SUM_D\nDEBUG:f90wrap.parser:        implicit type of \"SUM_D\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function SUM_D\nDEBUG:f90wrap.parser:    module function checking Set_NaN\nDEBUG:f90wrap.parser:        implicit type of \"Set_NaN\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function Set_NaN\nDEBUG:f90wrap.parser:  module Dual_Num_Auto_Diff\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type dual_num defined in module dual_num_auto_diff\nDerived types detected in Fortran source files:\n{'class(dual_num)': Type(name=dual_num),\n 'dual_num': Type(name=dual_num),\n 'type(dual_num)': Type(name=dual_num)}\n\nClass name mapping:\n{'class(dual_num)': 'DUAL_NUM',\n 'dual_num': 'DUAL_NUM',\n 'type(dual_num)': 'DUAL_NUM'}\nModules for each type:\n{'dual_num_auto_diff': 'dual_num_auto_diff'}\nDEBUG:f90wrap.fortran:type dual_num defined in module dual_num_auto_diff\nDEBUG:f90wrap.transform:marking public symbol cyldnad\nDEBUG:f90wrap.transform:marking public symbol dual_num\nDEBUG:f90wrap.transform:marking public symbol ndv_ad\nDEBUG:f90wrap.transform:marking private symbol sng_ad\nDEBUG:f90wrap.transform:marking private symbol dbl_ad\nDEBUG:f90wrap.transform:marking private symbol negative_one\nDEBUG:f90wrap.transform:marking private symbol set_nan\nDEBUG:f90wrap.transform:marking private symbol assignment(=)\nDEBUG:f90wrap.transform:marking private symbol assign_id\nDEBUG:f90wrap.transform:marking private symbol assign_dr\nDEBUG:f90wrap.transform:marking private symbol assign_ds\nDEBUG:f90wrap.transform:marking private symbol assign_di\nDEBUG:f90wrap.transform:marking private symbol operator(+)\nDEBUG:f90wrap.transform:marking private symbol add_ds\nDEBUG:f90wrap.transform:marking private symbol add_d\nDEBUG:f90wrap.transform:marking private symbol add_dd\nDEBUG:f90wrap.transform:marking private symbol add_sd\nDEBUG:f90wrap.transform:marking private symbol add_id\nDEBUG:f90wrap.transform:marking private symbol add_di\nDEBUG:f90wrap.transform:marking private symbol add_rd\nDEBUG:f90wrap.transform:marking private symbol add_dr\nDEBUG:f90wrap.transform:marking private symbol operator(-)\nDEBUG:f90wrap.transform:marking private symbol minus_dd\nDEBUG:f90wrap.transform:marking private symbol minus_rd\nDEBUG:f90wrap.transform:marking private symbol minus_ds\nDEBUG:f90wrap.transform:marking private symbol minus_sd\nDEBUG:f90wrap.transform:marking private symbol minus_d\nDEBUG:f90wrap.transform:marking private symbol minus_di\nDEBUG:f90wrap.transform:marking private symbol minus_dr\nDEBUG:f90wrap.transform:marking private symbol minus_id\nDEBUG:f90wrap.transform:marking private symbol operator(*)\nDEBUG:f90wrap.transform:marking private symbol mult_ds\nDEBUG:f90wrap.transform:marking private symbol mult_di\nDEBUG:f90wrap.transform:marking private symbol mult_dr\nDEBUG:f90wrap.transform:marking private symbol mult_rd\nDEBUG:f90wrap.transform:marking private symbol mult_dd\nDEBUG:f90wrap.transform:marking private symbol mult_sd\nDEBUG:f90wrap.transform:marking private symbol mult_id\nDEBUG:f90wrap.transform:marking private symbol operator(/)\nDEBUG:f90wrap.transform:marking private symbol div_di\nDEBUG:f90wrap.transform:marking private symbol div_ds\nDEBUG:f90wrap.transform:marking private symbol div_dr\nDEBUG:f90wrap.transform:marking private symbol div_rd\nDEBUG:f90wrap.transform:marking private symbol div_dd\nDEBUG:f90wrap.transform:marking private symbol div_id\nDEBUG:f90wrap.transform:marking private symbol div_sd\nDEBUG:f90wrap.transform:marking private symbol operator(**)\nDEBUG:f90wrap.transform:marking private symbol pow_r\nDEBUG:f90wrap.transform:marking private symbol pow_s\nDEBUG:f90wrap.transform:marking private symbol pow_d\nDEBUG:f90wrap.transform:marking private symbol pow_i\nDEBUG:f90wrap.transform:marking private symbol operator(==)\nDEBUG:f90wrap.transform:marking private symbol eq_dr\nDEBUG:f90wrap.transform:marking private symbol eq_rd\nDEBUG:f90wrap.transform:marking private symbol eq_sd\nDEBUG:f90wrap.transform:marking private symbol eq_di\nDEBUG:f90wrap.transform:marking private symbol eq_ds\nDEBUG:f90wrap.transform:marking private symbol eq_id\nDEBUG:f90wrap.transform:marking private symbol eq_dd\nDEBUG:f90wrap.transform:marking private symbol operator(<=)\nDEBUG:f90wrap.transform:marking private symbol le_ds\nDEBUG:f90wrap.transform:marking private symbol le_sd\nDEBUG:f90wrap.transform:marking private symbol le_id\nDEBUG:f90wrap.transform:marking private symbol le_rd\nDEBUG:f90wrap.transform:marking private symbol le_di\nDEBUG:f90wrap.transform:marking private symbol le_dr\nDEBUG:f90wrap.transform:marking private symbol le_dd\nDEBUG:f90wrap.transform:marking private symbol operator(<)\nDEBUG:f90wrap.transform:marking private symbol lt_rd\nDEBUG:f90wrap.transform:marking private symbol lt_ds\nDEBUG:f90wrap.transform:marking private symbol lt_dr\nDEBUG:f90wrap.transform:marking private symbol lt_dd\nDEBUG:f90wrap.transform:marking private symbol lt_di\nDEBUG:f90wrap.transform:marking private symbol lt_sd\nDEBUG:f90wrap.transform:marking private symbol lt_id\nDEBUG:f90wrap.transform:marking private symbol operator(>=)\nDEBUG:f90wrap.transform:marking private symbol ge_sd\nDEBUG:f90wrap.transform:marking private symbol ge_dd\nDEBUG:f90wrap.transform:marking private symbol ge_ds\nDEBUG:f90wrap.transform:marking private symbol ge_id\nDEBUG:f90wrap.transform:marking private symbol ge_di\nDEBUG:f90wrap.transform:marking private symbol ge_rd\nDEBUG:f90wrap.transform:marking private symbol ge_dr\nDEBUG:f90wrap.transform:marking private symbol operator(>)\nDEBUG:f90wrap.transform:marking private symbol gt_sd\nDEBUG:f90wrap.transform:marking private symbol gt_di\nDEBUG:f90wrap.transform:marking private symbol gt_rd\nDEBUG:f90wrap.transform:marking private symbol gt_ds\nDEBUG:f90wrap.transform:marking private symbol gt_dr\nDEBUG:f90wrap.transform:marking private symbol gt_dd\nDEBUG:f90wrap.transform:marking private symbol gt_id\nDEBUG:f90wrap.transform:marking private symbol operator(/=)\nDEBUG:f90wrap.transform:marking private symbol ne_dd\nDEBUG:f90wrap.transform:marking private symbol ne_sd\nDEBUG:f90wrap.transform:marking private symbol ne_di\nDEBUG:f90wrap.transform:marking private symbol ne_dr\nDEBUG:f90wrap.transform:marking private symbol ne_rd\nDEBUG:f90wrap.transform:marking private symbol ne_ds\nDEBUG:f90wrap.transform:marking private symbol ne_id\nDEBUG:f90wrap.transform:marking private symbol abs_d\nDEBUG:f90wrap.transform:marking private symbol acos_d\nDEBUG:f90wrap.transform:marking private symbol asin_d\nDEBUG:f90wrap.transform:marking private symbol cos_d\nDEBUG:f90wrap.transform:marking private symbol dot_product_dd\nDEBUG:f90wrap.transform:marking private symbol exp_d\nDEBUG:f90wrap.transform:marking private symbol int_d\nDEBUG:f90wrap.transform:marking private symbol log_d\nDEBUG:f90wrap.transform:marking private symbol log10_d\nDEBUG:f90wrap.transform:marking private symbol matmul_vd\nDEBUG:f90wrap.transform:marking private symbol matmul_dd\nDEBUG:f90wrap.transform:marking private symbol matmul_dv\nDEBUG:f90wrap.transform:marking private symbol max_dd\nDEBUG:f90wrap.transform:marking private symbol max_ds\nDEBUG:f90wrap.transform:marking private symbol max_rd\nDEBUG:f90wrap.transform:marking private symbol max_dr\nDEBUG:f90wrap.transform:marking private symbol max_di\nDEBUG:f90wrap.transform:marking private symbol maxval_d\nDEBUG:f90wrap.transform:marking private symbol min_dr\nDEBUG:f90wrap.transform:marking private symbol min_ds\nDEBUG:f90wrap.transform:marking private symbol min_dd\nDEBUG:f90wrap.transform:marking private symbol minval_d\nDEBUG:f90wrap.transform:marking private symbol nint_d\nDEBUG:f90wrap.transform:marking private symbol sign_dd\nDEBUG:f90wrap.transform:marking private symbol sign_rd\nDEBUG:f90wrap.transform:marking private symbol sin_d\nDEBUG:f90wrap.transform:marking private symbol sqrt_d\nDEBUG:f90wrap.transform:marking private symbol sum_d\nDEBUG:f90wrap.transform:removing private symbol sng_ad\nDEBUG:f90wrap.transform:removing private symbol dbl_ad\nDEBUG:f90wrap.transform:removing private symbol negative_one\nDEBUG:f90wrap.transform:removing private symbol set_nan\nDEBUG:f90wrap.transform:removing private symbol on interface assignment(=)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(+)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(-)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(*)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(/)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(**)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(==)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(<=)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(<)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(>=)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(>)\nDEBUG:f90wrap.transform:removing private symbol on interface operator(/=)\nWARNING:f90wrap.transform:removing routine dot_product_dd due to derived type array argument : u -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nWARNING:f90wrap.transform:removing routine matmul_vd due to derived type array argument : u -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nWARNING:f90wrap.transform:removing routine matmul_dd due to derived type array argument : u -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nWARNING:f90wrap.transform:removing routine matmul_dv due to derived type array argument : u -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nWARNING:f90wrap.transform:removing routine maxval_d due to derived type array argument : u -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nWARNING:f90wrap.transform:removing routine minval_d due to derived type array argument : u -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nWARNING:f90wrap.transform:removing routine sum_d due to derived type array argument : u -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nINFO:f90wrap.transform:setting call_name of abs_d to abs\nINFO:f90wrap.transform:setting call_name of abs_d to dabs\nINFO:f90wrap.transform:setting call_name of acos_d to acos\nINFO:f90wrap.transform:setting call_name of asin_d to asin\nINFO:f90wrap.transform:setting call_name of cos_d to cos\nINFO:f90wrap.transform:setting call_name of cos_d to dcos\nINFO:f90wrap.transform:setting call_name of exp_d to exp\nINFO:f90wrap.transform:setting call_name of int_d to int\nINFO:f90wrap.transform:setting call_name of log_d to log\nINFO:f90wrap.transform:setting call_name of log10_d to log10\nINFO:f90wrap.transform:setting call_name of max_dd to max\nINFO:f90wrap.transform:setting call_name of max_ds to max\nINFO:f90wrap.transform:setting call_name of max_rd to max\nINFO:f90wrap.transform:setting call_name of max_dr to max\nINFO:f90wrap.transform:setting call_name of max_di to max\nINFO:f90wrap.transform:setting call_name of max_dd to dmax1\nINFO:f90wrap.transform:setting call_name of min_dr to min\nINFO:f90wrap.transform:setting call_name of min_ds to min\nINFO:f90wrap.transform:setting call_name of min_dd to min\nINFO:f90wrap.transform:setting call_name of min_dd to dmin1\nINFO:f90wrap.transform:setting call_name of nint_d to nint\nINFO:f90wrap.transform:setting call_name of sign_dd to sign\nINFO:f90wrap.transform:setting call_name of sign_rd to sign\nINFO:f90wrap.transform:setting call_name of sin_d to sin\nINFO:f90wrap.transform:setting call_name of sin_d to dsin\nINFO:f90wrap.transform:setting call_name of sqrt_d to sqrt\nDEBUG:f90wrap.transform:collapsing single-component interface abs_d\nDEBUG:f90wrap.transform:collapsing single-component interface abs_d\nDEBUG:f90wrap.transform:collapsing single-component interface acos_d\nDEBUG:f90wrap.transform:collapsing single-component interface asin_d\nDEBUG:f90wrap.transform:collapsing single-component interface cos_d\nDEBUG:f90wrap.transform:collapsing single-component interface cos_d\nDEBUG:f90wrap.transform:collapsing single-component interface exp_d\nDEBUG:f90wrap.transform:collapsing single-component interface int_d\nDEBUG:f90wrap.transform:collapsing single-component interface log_d\nDEBUG:f90wrap.transform:collapsing single-component interface log10_d\nDEBUG:f90wrap.transform:collapsing single-component interface max_dd\nDEBUG:f90wrap.transform:collapsing single-component interface min_dd\nDEBUG:f90wrap.transform:collapsing single-component interface nint_d\nDEBUG:f90wrap.transform:collapsing single-component interface sin_d\nDEBUG:f90wrap.transform:collapsing single-component interface sin_d\nDEBUG:f90wrap.transform:collapsing single-component interface sqrt_d\nDEBUG:f90wrap.transform:visiting Module(name=mcyldnad)\nDEBUG:f90wrap.transform:visiting Module(name=dual_num_auto_diff)\nDEBUG:f90wrap.transform:visiting Type(name=dual_num)\nINFO:f90wrap.transform:adding missing constructor for dual_num\nINFO:f90wrap.transform:adding missing destructor for dual_num\nDEBUG:f90wrap.transform:visiting Module(name=mcyldnad)\nINFO:f90wrap.transform:visiting Module(name=mcyldnad) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Module(name=dual_num_auto_diff)\nINFO:f90wrap.transform:visiting Module(name=dual_num_auto_diff) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=dual_num)\nINFO:f90wrap.transform:visiting Type(name=dual_num) found 1 constructors with names: ['dual_num_initialise']\nDEBUG:f90wrap.transform:allocating arg \"vol\" in cyldnad\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in abs_d\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in abs_d\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in acos_d\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in asin_d\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in cos_d\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in cos_d\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in exp_d\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in log_d\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in log10_d\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in max_dd\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in min_dd\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in sin_d\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in sin_d\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in sqrt_d\nDEBUG:f90wrap.transform:allocating arg \"this\" in dual_num_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in dual_num_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in max_dd\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in max_ds\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in max_rd\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in max_dr\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in max_di\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in min_dr\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in min_ds\nDEBUG:f90wrap.transform:allocating arg \"ret_ret_res\" in min_dd\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in sign_dd\nDEBUG:f90wrap.transform:allocating arg \"ret_res\" in sign_rd\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _cylinder_directmodule.c\nINFO:root:Generated Fortran support module: cylinder_direct_support.f90\nINFO:root:Generated minimal Python wrapper: cylinder_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['cyldnad.fpp', 'DNAD.fpp']",
        "Command: f90wrap -m cylinder_direct /tmp/tmpmmzigjx2/cyldnad.fpp /tmp/tmpmmzigjx2/DNAD.fpp -k /tmp/tmpmmzigjx2/kind_map --direct-c -v",
        "Generated C files: ['_cylinder_directmodule.c', '_test_directmodule.c']",
        "Preprocessed cyldnad.fpp -> cyldnad_processed.f90",
        "Preprocessed DNAD.fpp -> DNAD_processed.f90",
        "Found support module: cylinder_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c cyldnad_processed.f90 DNAD_processed.f90 cylinder_direct_support.f90",
        "Fortran compilation failed: /home/ert/code/f90wrap/examples/cylinder/cyldnad.f90:6:7:\n\n    6 |   USE Dual_Num_Auto_Diff\n      |       1\nFatal Error: Cannot open module file \u2018dual_num_auto_diff.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\ncylinder_direct_support.f90:6:9:\n\n    6 |     use mcyldnad\n      |         1\nFatal Error: Cannot open module file \u2018mcyldnad.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\n"
      ]
    },
    {
      "name": "default_i8",
      "path": "/home/ert/code/f90wrap/examples/default_i8",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'': 'long_long', '4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp7w81zhnp/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp7w81zhnp/test.fpp\nINFO:f90wrap.parser:parser reading type mytype\nDEBUG:f90wrap.parser:    type mytype\nDEBUG:f90wrap.parser:    module subroutine checking allocit\nDEBUG:f90wrap.parser:    module subroutine allocit\nDEBUG:f90wrap.parser:  module my_module\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type mytype defined in module my_module\nDerived types detected in Fortran source files:\n{'class(mytype)': Type(name=mytype),\n 'mytype': Type(name=mytype),\n 'type(mytype)': Type(name=mytype)}\n\nClass name mapping:\n{'class(mytype)': 'mytype', 'mytype': 'mytype', 'type(mytype)': 'mytype'}\nModules for each type:\n{'my_module': 'my_module'}\nDEBUG:f90wrap.fortran:type mytype defined in module my_module\nDEBUG:f90wrap.transform:marking public symbol mytype\nDEBUG:f90wrap.transform:marking public symbol allocit\nDEBUG:f90wrap.transform:visiting Module(name=my_module)\nDEBUG:f90wrap.transform:visiting Type(name=mytype)\nINFO:f90wrap.transform:adding missing constructor for mytype\nINFO:f90wrap.transform:adding missing destructor for mytype\nDEBUG:f90wrap.transform:visiting Module(name=my_module)\nINFO:f90wrap.transform:visiting Module(name=my_module) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=mytype)\nINFO:f90wrap.transform:visiting Type(name=mytype) found 1 constructors with names: ['mytype_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in mytype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in mytype_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _default_i8_directmodule.c\nINFO:root:Generated Fortran support module: default_i8_direct_support.f90\nINFO:root:Generated minimal Python wrapper: default_i8_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m default_i8_direct /tmp/tmp7w81zhnp/test.fpp -k /tmp/tmp7w81zhnp/kind_map --direct-c -v",
        "Generated C files: ['_default_i8_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Found support module: default_i8_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90 default_i8_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _default_i8_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _default_i8_directmodule.o",
        "Linking: gcc -shared _default_i8_directmodule.o default_i8_direct_support.o test_processed.o -lgfortran -o _default_i8_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "derived-type-aliases",
      "path": "/home/ert/code/f90wrap/examples/derived-type-aliases",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dp': 'double',\n          'idp': 'double',\n          'isp': 'float'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmprj9cenif/othertype_mod.fpp', '/tmp/tmprj9cenif/mytype_mod.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmprj9cenif/othertype_mod.fpp\nINFO:f90wrap.parser:parser reading type othertype\nDEBUG:f90wrap.parser:    type othertype\nDEBUG:f90wrap.parser:    module function checking constructor\nDEBUG:f90wrap.parser:        implicit type of \"constructor\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function constructor\nDEBUG:f90wrap.parser:    module subroutine checking plus_b\nDEBUG:f90wrap.parser:    module subroutine plus_b\nDEBUG:f90wrap.parser:  module othertype_mod\nDEBUG:f90wrap.parser:processing file /tmp/tmprj9cenif/mytype_mod.fpp\nINFO:f90wrap.parser:parser reading type mytype\nDEBUG:f90wrap.parser:    type mytype\nDEBUG:f90wrap.parser:    module function checking constructor\nDEBUG:f90wrap.parser:        implicit type of \"constructor\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function constructor\nDEBUG:f90wrap.parser:    module subroutine checking plus_b\nDEBUG:f90wrap.parser:    module subroutine plus_b\nDEBUG:f90wrap.parser:  module mytype_mod\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type othertype defined in module othertype_mod\nDEBUG:f90wrap.fortran:type mytype defined in module mytype_mod\nDerived types detected in Fortran source files:\n{'class(mytype)': Type(name=mytype),\n 'class(othertype)': Type(name=othertype),\n 'mytype': Type(name=mytype),\n 'othertype': Type(name=othertype),\n 'type(mytype)': Type(name=mytype),\n 'type(othertype)': Type(name=othertype)}\n\nClass name mapping:\n{'class(mytype)': 'mytype',\n 'class(othertype)': 'othertype',\n 'mytype': 'mytype',\n 'othertype': 'othertype',\n 'type(mytype)': 'mytype',\n 'type(othertype)': 'othertype'}\nModules for each type:\n{'mytype_mod': 'mytype_mod', 'othertype_mod': 'othertype_mod'}\nDEBUG:f90wrap.fortran:type othertype defined in module othertype_mod\nDEBUG:f90wrap.fortran:type mytype defined in module mytype_mod\nDEBUG:f90wrap.transform:marking public symbol othertype\nDEBUG:f90wrap.transform:marking public symbol constructor\nDEBUG:f90wrap.transform:marking public symbol plus_b\nDEBUG:f90wrap.transform:marking public symbol mytype\nDEBUG:f90wrap.transform:marking public symbol constructor\nDEBUG:f90wrap.transform:marking public symbol plus_b\nDEBUG:f90wrap.transform:visiting Module(name=othertype_mod)\nDEBUG:f90wrap.transform:visiting Type(name=othertype)\nDEBUG:f90wrap.transform:visiting Module(name=mytype_mod)\nDEBUG:f90wrap.transform:visiting Type(name=mytype)\nINFO:f90wrap.transform:adding missing constructor for othertype\nINFO:f90wrap.transform:adding missing constructor for mytype\nINFO:f90wrap.transform:adding missing destructor for othertype\nINFO:f90wrap.transform:adding missing destructor for mytype\nDEBUG:f90wrap.transform:visiting Module(name=othertype_mod)\nINFO:f90wrap.transform:visiting Module(name=othertype_mod) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=othertype)\nINFO:f90wrap.transform:visiting Type(name=othertype) found 1 constructors with names: ['othertype_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=mytype_mod)\nINFO:f90wrap.transform:visiting Module(name=mytype_mod) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=mytype)\nINFO:f90wrap.transform:visiting Type(name=mytype) found 1 constructors with names: ['mytype_initialise']\nDEBUG:f90wrap.transform:allocating arg \"ret_obj\" in constructor\nDEBUG:f90wrap.transform:allocating arg \"ret_obj\" in constructor\nDEBUG:f90wrap.transform:allocating arg \"this\" in othertype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in othertype_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in mytype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in mytype_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _derived-type-aliases_directmodule.c\nINFO:root:Generated Fortran support module: derived-type-aliases_direct_support.f90\nINFO:root:Generated minimal Python wrapper: derived-type-aliases_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['othertype_mod.fpp', 'mytype_mod.fpp']",
        "Command: f90wrap -m derived-type-aliases_direct /tmp/tmprj9cenif/othertype_mod.fpp /tmp/tmprj9cenif/mytype_mod.fpp -k /tmp/tmprj9cenif/kind_map --direct-c -v",
        "Generated C files: ['_derived-type-aliases_directmodule.c']",
        "Preprocessed othertype_mod.fpp -> othertype_mod_processed.f90",
        "Preprocessed mytype_mod.fpp -> mytype_mod_processed.f90",
        "Found support module: derived-type-aliases_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c othertype_mod_processed.f90 mytype_mod_processed.f90 derived-type-aliases_direct_support.f90",
        "Fortran compilation failed: derived-type-aliases_direct_support.f90:4:8:\n\n    4 | module f90wrap__derived-type-aliases_direct_support\n      |        1\nError: MODULE prefix at (1) found outside of a module, submodule, or interface\nderived-type-aliases_direct_support.f90:13:111:\n\n   13 |     subroutine f90wrap_othertype__allocate(ptr) bind(C, name='__othertype_mod_MOD_f90wrap_othertype__allocate')\n      |                                                                                                               1\nError: No"
      ]
    },
    {
      "name": "derivedtypes",
      "path": "/home/ert/code/f90wrap/examples/derivedtypes",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char', '1': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dp': 'double',\n          'idp': 'double',\n          'isp': 'float'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpur1w7fxt/datatypes.fpp', '/tmp/tmpur1w7fxt/library.fpp', '/tmp/tmpur1w7fxt/parameters.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpur1w7fxt/datatypes.fpp\nINFO:f90wrap.parser:parser reading type alloc_arrays\nDEBUG:f90wrap.parser:    type alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine checking init_alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine init_alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine checking destroy_alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine destroy_alloc_arrays\nDEBUG:f90wrap.parser:  module datatypes_allocatable\nINFO:f90wrap.parser:parser reading type different_types\nDEBUG:f90wrap.parser:    type different_types\nINFO:f90wrap.parser:parser reading type fixed_shape_arrays\nDEBUG:f90wrap.parser:    type fixed_shape_arrays\nINFO:f90wrap.parser:parser reading type nested\nDEBUG:f90wrap.parser:    type nested\nINFO:f90wrap.parser:parser reading type pointer_arrays\nDEBUG:f90wrap.parser:    type pointer_arrays\nINFO:f90wrap.parser:parser reading type alloc_arrays_2\nDEBUG:f90wrap.parser:    type alloc_arrays_2\nINFO:f90wrap.parser:parser reading type array_nested\nDEBUG:f90wrap.parser:    type array_nested\nDEBUG:f90wrap.parser:    module subroutine checking init_array_nested\nDEBUG:f90wrap.parser:    module subroutine init_array_nested\nDEBUG:f90wrap.parser:    module subroutine checking destroy_array_nested\nDEBUG:f90wrap.parser:    module subroutine destroy_array_nested\nDEBUG:f90wrap.parser:  module datatypes\nDEBUG:f90wrap.parser:processing file /tmp/tmpur1w7fxt/library.fpp\nDEBUG:f90wrap.parser:    module function checking return_value_func\nDEBUG:f90wrap.parser:        implicit type of \"return_value_func\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_value_func\nDEBUG:f90wrap.parser:    module subroutine checking return_value_sub\nDEBUG:f90wrap.parser:    module subroutine return_value_sub\nDEBUG:f90wrap.parser:    module function checking return_a_dt_func\nDEBUG:f90wrap.parser:        implicit type of \"return_a_dt_func\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_a_dt_func\nDEBUG:f90wrap.parser:    module subroutine checking do_array_stuff\nDEBUG:f90wrap.parser:    module subroutine do_array_stuff\nDEBUG:f90wrap.parser:    module subroutine checking only_manipulate\nDEBUG:f90wrap.parser:    module subroutine only_manipulate\nDEBUG:f90wrap.parser:    module subroutine checking set_derived_type\nDEBUG:f90wrap.parser:    module subroutine set_derived_type\nDEBUG:f90wrap.parser:    module subroutine checking modify_derived_types\nDEBUG:f90wrap.parser:    module subroutine modify_derived_types\nDEBUG:f90wrap.parser:    module subroutine checking modify_dertype_fixed_shape_arrays\nDEBUG:f90wrap.parser:    module subroutine modify_dertype_fixed_shape_arrays\nDEBUG:f90wrap.parser:    module subroutine checking return_dertype_pointer_arrays\nDEBUG:f90wrap.parser:    module subroutine return_dertype_pointer_arrays\nDEBUG:f90wrap.parser:    module subroutine checking modify_dertype_pointer_arrays\nDEBUG:f90wrap.parser:    module subroutine modify_dertype_pointer_arrays\nDEBUG:f90wrap.parser:    module subroutine checking return_dertype_alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine return_dertype_alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine checking modify_dertype_alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine modify_dertype_alloc_arrays\nDEBUG:f90wrap.parser:    module subroutine checking return_array_nested\nDEBUG:f90wrap.parser:    module subroutine return_array_nested\nDEBUG:f90wrap.parser:  module library\nDEBUG:f90wrap.parser:processing file /tmp/tmpur1w7fxt/parameters.fpp\nINFO:f90wrap.parser:marking module parameters as default private\nDEBUG:f90wrap.parser:  module parameters\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type alloc_arrays defined in module datatypes_allocatable\nDEBUG:f90wrap.fortran:type different_types defined in module datatypes\nDEBUG:f90wrap.fortran:type fixed_shape_arrays defined in module datatypes\nDEBUG:f90wrap.fortran:type nested defined in module datatypes\nDEBUG:f90wrap.fortran:type pointer_arrays defined in module datatypes\nDEBUG:f90wrap.fortran:type alloc_arrays_2 defined in module datatypes\nDEBUG:f90wrap.fortran:type array_nested defined in module datatypes\nDerived types detected in Fortran source files:\n{'alloc_arrays': Type(name=alloc_arrays),\n 'alloc_arrays_2': Type(name=alloc_arrays_2),\n 'array_nested': Type(name=array_nested),\n 'class(alloc_arrays)': Type(name=alloc_arrays),\n 'class(alloc_arrays_2)': Type(name=alloc_arrays_2),\n 'class(array_nested)': Type(name=array_nested),\n 'class(different_types)': Type(name=different_types),\n 'class(fixed_shape_arrays)': Type(name=fixed_shape_arrays),\n 'class(nested)': Type(name=nested),\n 'class(pointer_arrays)': Type(name=pointer_arrays),\n 'different_types': Type(name=different_types),\n 'fixed_shape_arrays': Type(name=fixed_shape_arrays),\n 'nested': Type(name=nested),\n 'pointer_arrays': Type(name=pointer_arrays),\n 'type(alloc_arrays)': Type(name=alloc_arrays),\n 'type(alloc_arrays_2)': Type(name=alloc_arrays_2),\n 'type(array_nested)': Type(name=array_nested),\n 'type(different_types)': Type(name=different_types),\n 'type(fixed_shape_arrays)': Type(name=fixed_shape_arrays),\n 'type(nested)': Type(name=nested),\n 'type(pointer_arrays)': Type(name=pointer_arrays)}\n\nClass name mapping:\n{'alloc_arrays': 'alloc_arrays',\n 'alloc_arrays_2': 'alloc_arrays_2',\n 'array_nested': 'array_nested',\n 'class(alloc_arrays)': 'alloc_arrays',\n 'class(alloc_arrays_2)': 'alloc_arrays_2',\n 'class(array_nested)': 'array_nested',\n 'class(different_types)': 'different_types',\n 'class(fixed_shape_arrays)': 'fixed_shape_arrays',\n 'class(nested)': 'nested',\n 'class(pointer_arrays)': 'pointer_arrays',\n 'different_types': 'different_types',\n 'fixed_shape_arrays': 'fixed_shape_arrays',\n 'nested': 'nested',\n 'pointer_arrays': 'pointer_arrays',\n 'type(alloc_arrays)': 'alloc_arrays',\n 'type(alloc_arrays_2)': 'alloc_arrays_2',\n 'type(array_nested)': 'array_nested',\n 'type(different_types)': 'different_types',\n 'type(fixed_shape_arrays)': 'fixed_shape_arrays',\n 'type(nested)': 'nested',\n 'type(pointer_arrays)': 'pointer_arrays'}\nModules for each type:\n{'datatypes': 'datatypes', 'datatypes_allocatable': 'datatypes_allocatable'}\nDEBUG:f90wrap.fortran:type alloc_arrays defined in module datatypes_allocatable\nDEBUG:f90wrap.fortran:type different_types defined in module datatypes\nDEBUG:f90wrap.fortran:type fixed_shape_arrays defined in module datatypes\nDEBUG:f90wrap.fortran:type nested defined in module datatypes\nDEBUG:f90wrap.fortran:type pointer_arrays defined in module datatypes\nDEBUG:f90wrap.fortran:type alloc_arrays_2 defined in module datatypes\nDEBUG:f90wrap.fortran:type array_nested defined in module datatypes\nDEBUG:f90wrap.transform:marking public symbol alloc_arrays\nDEBUG:f90wrap.transform:marking public symbol init_alloc_arrays\nDEBUG:f90wrap.transform:marking public symbol destroy_alloc_arrays\nDEBUG:f90wrap.transform:marking public symbol different_types\nDEBUG:f90wrap.transform:marking public symbol fixed_shape_arrays\nDEBUG:f90wrap.transform:marking public symbol nested\nDEBUG:f90wrap.transform:marking public symbol pointer_arrays\nDEBUG:f90wrap.transform:marking public symbol alloc_arrays_2\nDEBUG:f90wrap.transform:marking public symbol array_nested\nDEBUG:f90wrap.transform:marking public symbol init_array_nested\nDEBUG:f90wrap.transform:marking public symbol destroy_array_nested\nDEBUG:f90wrap.transform:marking public symbol return_dertype_pointer_arrays\nDEBUG:f90wrap.transform:marking public symbol only_manipulate\nDEBUG:f90wrap.transform:marking public symbol return_a_dt_func\nDEBUG:f90wrap.transform:marking public symbol return_dertype_alloc_arrays\nDEBUG:f90wrap.transform:marking public symbol modify_dertype_alloc_arrays\nDEBUG:f90wrap.transform:marking public symbol return_value_func\nDEBUG:f90wrap.transform:marking public symbol do_array_stuff\nDEBUG:f90wrap.transform:marking public symbol modify_dertype_pointer_arrays\nDEBUG:f90wrap.transform:marking public symbol modify_derived_types\nDEBUG:f90wrap.transform:marking public symbol return_value_sub\nDEBUG:f90wrap.transform:marking public symbol set_derived_type\nDEBUG:f90wrap.transform:marking public symbol modify_dertype_fixed_shape_arrays\nDEBUG:f90wrap.transform:marking public symbol return_array_nested\nWARNING:f90wrap.transform:removing routine return_array_nested due to derived type array argument : dt_array -- currently, only fixed-lengh one-dimensional arrays of derived type are supported\nDEBUG:f90wrap.transform:visiting Module(name=datatypes_allocatable)\nDEBUG:f90wrap.transform:visiting Type(name=alloc_arrays)\nDEBUG:f90wrap.transform:visiting Module(name=datatypes)\nDEBUG:f90wrap.transform:visiting Type(name=different_types)\nDEBUG:f90wrap.transform:visiting Type(name=fixed_shape_arrays)\nDEBUG:f90wrap.transform:visiting Type(name=nested)\nDEBUG:f90wrap.transform:visiting Type(name=pointer_arrays)\nDEBUG:f90wrap.transform:visiting Type(name=alloc_arrays_2)\nDEBUG:f90wrap.transform:visiting Type(name=array_nested)\nDEBUG:f90wrap.transform:visiting Module(name=library)\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nINFO:f90wrap.transform:adding missing constructor for alloc_arrays\nINFO:f90wrap.transform:adding missing constructor for different_types\nINFO:f90wrap.transform:adding missing constructor for fixed_shape_arrays\nINFO:f90wrap.transform:adding missing constructor for nested\nINFO:f90wrap.transform:adding missing constructor for pointer_arrays\nINFO:f90wrap.transform:adding missing constructor for alloc_arrays_2\nINFO:f90wrap.transform:adding missing constructor for array_nested\nINFO:f90wrap.transform:adding missing destructor for alloc_arrays\nINFO:f90wrap.transform:adding missing destructor for different_types\nINFO:f90wrap.transform:adding missing destructor for fixed_shape_arrays\nINFO:f90wrap.transform:adding missing destructor for nested\nINFO:f90wrap.transform:adding missing destructor for pointer_arrays\nINFO:f90wrap.transform:adding missing destructor for alloc_arrays_2\nINFO:f90wrap.transform:adding missing destructor for array_nested\nDEBUG:f90wrap.transform:visiting Module(name=datatypes_allocatable)\nINFO:f90wrap.transform:visiting Module(name=datatypes_allocatable) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=alloc_arrays)\nINFO:f90wrap.transform:visiting Type(name=alloc_arrays) found 1 constructors with names: ['alloc_arrays_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=datatypes)\nINFO:f90wrap.transform:visiting Module(name=datatypes) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=different_types)\nINFO:f90wrap.transform:visiting Type(name=different_types) found 1 constructors with names: ['different_types_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=fixed_shape_arrays)\nINFO:f90wrap.transform:visiting Type(name=fixed_shape_arrays) found 1 constructors with names: ['fixed_shape_arrays_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=nested)\nINFO:f90wrap.transform:visiting Type(name=nested) found 1 constructors with names: ['nested_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=pointer_arrays)\nINFO:f90wrap.transform:visiting Type(name=pointer_arrays) found 1 constructors with names: ['pointer_arrays_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=alloc_arrays_2)\nINFO:f90wrap.transform:visiting Type(name=alloc_arrays_2) found 1 constructors with names: ['alloc_arrays_2_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=array_nested)\nINFO:f90wrap.transform:visiting Type(name=array_nested) found 1 constructors with names: ['array_nested_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=library)\nINFO:f90wrap.transform:visiting Module(name=library) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nINFO:f90wrap.transform:visiting Module(name=parameters) found 0 constructors with names: []\nDEBUG:f90wrap.transform:allocating arg \"dertype\" in return_dertype_pointer_arrays\nDEBUG:f90wrap.transform:allocating arg \"ret_dt\" in return_a_dt_func\nDEBUG:f90wrap.transform:allocating arg \"dertype\" in return_dertype_alloc_arrays\nDEBUG:f90wrap.transform:allocating arg \"dt\" in set_derived_type\nDEBUG:f90wrap.transform:allocating arg \"dertype\" in modify_dertype_fixed_shape_arrays\nDEBUG:f90wrap.transform:allocating arg \"this\" in alloc_arrays_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in alloc_arrays_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in different_types_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in different_types_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in fixed_shape_arrays_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in fixed_shape_arrays_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in nested_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in nested_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in pointer_arrays_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in pointer_arrays_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in alloc_arrays_2_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in alloc_arrays_2_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in array_nested_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in array_nested_finalise\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to only_manipulate\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2)] to do_array_stuff\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n3)] to do_array_stuff\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _derivedtypes_directmodule.c\nINFO:root:Generated Fortran support module: derivedtypes_direct_support.f90\nINFO:root:Generated minimal Python wrapper: derivedtypes_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "linking_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['datatypes.fpp', 'library.fpp', 'parameters.fpp']",
        "Command: f90wrap -m derivedtypes_direct /tmp/tmpur1w7fxt/datatypes.fpp /tmp/tmpur1w7fxt/library.fpp /tmp/tmpur1w7fxt/parameters.fpp -k /tmp/tmpur1w7fxt/kind_map --direct-c -v",
        "Generated C files: ['_derivedtypes_directmodule.c', '_test_directmodule.c']",
        "Preprocessed datatypes.fpp -> datatypes_processed.f90",
        "Preprocessed library.fpp -> library_processed.f90",
        "Preprocessed parameters.fpp -> parameters_processed.f90",
        "Found support module: derivedtypes_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c datatypes_processed.f90 library_processed.f90 parameters_processed.f90 derivedtypes_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _derivedtypes_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _derivedtypes_directmodule.o",
        "Compiling C: gcc -fPIC -c _test_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _test_directmodule.o",
        "Linking: gcc -shared _test_directmodule.o _derivedtypes_directmodule.o derivedtypes_direct_support.o parameters_processed.o library_processed.o datatypes_processed.o datatypes.o test_direct_support.o library.o parameters.o -lgfortran -o _derivedtypes_direct.so",
        "Linking failed: /usr/bin/ld: datatypes.o:(.rodata+0x0): multiple definition of `__datatypes_allocatable_MOD___def_init_datatypes_allocatable_Alloc_arrays'; datatypes_processed.o:(.rodata+0x0): first defined here\n/usr/bin/ld: datatypes.o:(.data.rel.local+0x0): multiple definition of `__datatypes_allocatable_MOD___vtab_datatypes_allocatable_Alloc_arrays'; datatypes_processed.o:(.data.rel+0x0): first defined here\n/usr/bin/ld: datatypes.o: in function `__datatypes_allocatable_MOD___copy_datatypes_allocatable_Alloc_"
      ]
    },
    {
      "name": "derivedtypes_procedure",
      "path": "/home/ert/code/f90wrap/examples/derivedtypes_procedure",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpbapclxw6/library.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpbapclxw6/library.fpp\nINFO:f90wrap.parser:marking module test as default private\nINFO:f90wrap.parser:parser reading type atype\nDEBUG:f90wrap.parser:parser reading type atype bound procedures\nDEBUG:f90wrap.parser:found procedure binding p_create => create_class\nDEBUG:f90wrap.parser:found procedure binding p_asum => asum_class\nDEBUG:f90wrap.parser:found procedure binding p_asum_2 => asum_class\nDEBUG:f90wrap.parser:found procedure binding asum_class => asum_class\nDEBUG:f90wrap.parser:found procedure binding p_reset => assignment_value\nDEBUG:f90wrap.parser:found generic binding assignment(=) =>  p_reset\nDEBUG:f90wrap.parser:    type atype\nINFO:f90wrap.parser:parser reading type btype\nDEBUG:f90wrap.parser:parser reading type btype bound procedures\nDEBUG:f90wrap.parser:found procedure binding p_asum => bsum_class\nDEBUG:f90wrap.parser:    type btype\nDEBUG:f90wrap.parser:    module subroutine checking create\nDEBUG:f90wrap.parser:    module subroutine create\nDEBUG:f90wrap.parser:    module subroutine checking create_class\nDEBUG:f90wrap.parser:    module subroutine create_class\nDEBUG:f90wrap.parser:    module function checking asum\nDEBUG:f90wrap.parser:        implicit type of \"asum\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function asum\nDEBUG:f90wrap.parser:    module function checking asum_class\nDEBUG:f90wrap.parser:        implicit type of \"asum_class\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function asum_class\nDEBUG:f90wrap.parser:    module subroutine checking assignment_value\nDEBUG:f90wrap.parser:    module subroutine assignment_value\nDEBUG:f90wrap.parser:    module function checking bsum_class\nDEBUG:f90wrap.parser:        implicit type of \"bsum_class\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function bsum_class\nDEBUG:f90wrap.parser:  module test\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type atype defined in module test\nDEBUG:f90wrap.fortran:type btype defined in module test\nDerived types detected in Fortran source files:\n{'atype': Type(name=atype),\n 'btype': Type(name=btype),\n 'class(atype)': Type(name=atype),\n 'class(btype)': Type(name=btype),\n 'type(atype)': Type(name=atype),\n 'type(btype)': Type(name=btype)}\n\nClass name mapping:\n{'atype': 'atype',\n 'btype': 'btype',\n 'class(atype)': 'atype',\n 'class(btype)': 'btype',\n 'type(atype)': 'atype',\n 'type(btype)': 'btype'}\nModules for each type:\n{'test': 'test'}\nDEBUG:f90wrap.transform:Creating method for atype from procedure create_class.\nDEBUG:f90wrap.transform:Creating method for atype from procedure asum_class.\nDEBUG:f90wrap.transform:Creating method for atype from procedure asum_class.\nDEBUG:f90wrap.transform:Creating method for atype from procedure asum_class.\nDEBUG:f90wrap.transform:Creating method for atype from procedure assignment_value.\nDEBUG:f90wrap.transform:Creating method for btype from procedure bsum_class.\nDEBUG:f90wrap.fortran:type atype defined in module test\nDEBUG:f90wrap.fortran:type btype defined in module test\nDEBUG:f90wrap.transform:marking private symbol assignment_value\nDEBUG:f90wrap.transform:marking private symbol bsum_class\nDEBUG:f90wrap.transform:marking private symbol create_class\nDEBUG:f90wrap.transform:removing private symbol assignment_value\nDEBUG:f90wrap.transform:removing private symbol bsum_class\nDEBUG:f90wrap.transform:removing private symbol create_class\nDEBUG:f90wrap.transform:visiting Module(name=test)\nDEBUG:f90wrap.transform:visiting Type(name=atype)\nDEBUG:f90wrap.transform:visiting Type(name=btype)\nINFO:f90wrap.transform:adding missing constructor for atype\nINFO:f90wrap.transform:adding missing constructor for btype\nINFO:f90wrap.transform:adding missing destructor for atype\nINFO:f90wrap.transform:adding missing destructor for btype\nDEBUG:f90wrap.transform:visiting Module(name=test)\nINFO:f90wrap.transform:visiting Module(name=test) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=atype)\nINFO:f90wrap.transform:visiting Type(name=atype) found 1 constructors with names: ['atype_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=btype)\nINFO:f90wrap.transform:visiting Type(name=btype) found 1 constructors with names: ['btype_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in atype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in atype_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in btype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in btype_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _derivedtypes_procedure_directmodule.c\nINFO:root:Generated Fortran support module: derivedtypes_procedure_direct_support.f90\nINFO:root:Generated minimal Python wrapper: derivedtypes_procedure_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['library.fpp']",
        "Command: f90wrap -m derivedtypes_procedure_direct /tmp/tmpbapclxw6/library.fpp  --direct-c -v",
        "Generated C files: ['_derivedtypes_procedure_directmodule.c']",
        "Preprocessed library.fpp -> library_processed.f90",
        "Found support module: derivedtypes_procedure_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c library_processed.f90 derivedtypes_procedure_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _derivedtypes_procedure_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _derivedtypes_procedure_directmodule.o",
        "Linking: gcc -shared _derivedtypes_procedure_directmodule.o derivedtypes_procedure_direct_support.o library_processed.o -lgfortran -o _derivedtypes_procedure_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "docstring",
      "path": "/home/ert/code/f90wrap/examples/docstring",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp5k7m4j73/main.fpp', '/tmp/tmp5k7m4j73/f90wrap_main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp5k7m4j73/main.fpp\nINFO:f90wrap.parser:marking module m_circle as default private\nINFO:f90wrap.parser:parser reading type t_circle\nDEBUG:f90wrap.parser:    type t_circle\nDEBUG:f90wrap.parser:    module subroutine checking construct_circle\nDEBUG:f90wrap.parser:    module subroutine construct_circle\nDEBUG:f90wrap.parser:    module subroutine checking construct_circle_more_doc\nDEBUG:f90wrap.parser:    module subroutine construct_circle_more_doc\nDEBUG:f90wrap.parser:    module subroutine checking no_direction\nDEBUG:f90wrap.parser:    module subroutine no_direction\nDEBUG:f90wrap.parser:    module subroutine checking incomplete_doc_sub\nDEBUG:f90wrap.parser:    module subroutine incomplete_doc_sub\nDEBUG:f90wrap.parser:    module subroutine checking doc_inside\nDEBUG:f90wrap.parser:    module subroutine doc_inside\nDEBUG:f90wrap.parser:    module subroutine checking output_1\nDEBUG:f90wrap.parser:    module subroutine output_1\nDEBUG:f90wrap.parser:    module function checking function_2\nDEBUG:f90wrap.parser:    module function function_2\nDEBUG:f90wrap.parser:    module subroutine checking details_doc\nDEBUG:f90wrap.parser:    module subroutine details_doc\nDEBUG:f90wrap.parser:    module subroutine checking details_with_parenthesis\nDEBUG:f90wrap.parser:    module subroutine details_with_parenthesis\nDEBUG:f90wrap.parser:    module subroutine checking multiline_details\nDEBUG:f90wrap.parser:    module subroutine multiline_details\nDEBUG:f90wrap.parser:    module subroutine checking empty_lines_details\nDEBUG:f90wrap.parser:    module subroutine empty_lines_details\nDEBUG:f90wrap.parser:    module subroutine checking long_line_brief\nDEBUG:f90wrap.parser:    module subroutine long_line_brief\nDEBUG:f90wrap.parser:  module m_circle\nDEBUG:f90wrap.parser:processing file /tmp/tmp5k7m4j73/f90wrap_main.fpp\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_t_circle__get__radius\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_t_circle__set__radius\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__t_circle_initialise\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__t_circle_finalise\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__output_1\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__construct_circle_more_doc\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__details_doc\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__no_direction\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__details_with_parenthesis\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__multiline_details\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__construct_circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__empty_lines_details\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__incomplete_doc_sub\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__doc_inside\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__function_2\nDEBUG:f90wrap.parser:        implicit type of \"input\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_circle__long_line_brief\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type t_circle defined in module m_circle\nDerived types detected in Fortran source files:\n{'class(t_circle)': Type(name=t_circle),\n 't_circle': Type(name=t_circle),\n 'type(t_circle)': Type(name=t_circle)}\n\nClass name mapping:\n{'class(t_circle)': 't_circle',\n 't_circle': 't_circle',\n 'type(t_circle)': 't_circle'}\nModules for each type:\n{'m_circle': 'm_circle'}\nDEBUG:f90wrap.fortran:type t_circle defined in module m_circle\nDEBUG:f90wrap.transform:marking public symbol t_circle\nDEBUG:f90wrap.transform:visiting Module(name=m_circle)\nDEBUG:f90wrap.transform:visiting Type(name=t_circle)\nINFO:f90wrap.transform:adding missing constructor for t_circle\nINFO:f90wrap.transform:adding missing destructor for t_circle\nDEBUG:f90wrap.transform:visiting Module(name=m_circle)\nINFO:f90wrap.transform:visiting Module(name=m_circle) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_circle)\nINFO:f90wrap.transform:visiting Type(name=t_circle) found 1 constructors with names: ['t_circle_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_circle_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_circle_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _docstring_directmodule.c\nINFO:root:Generated Fortran support module: docstring_direct_support.f90\nINFO:root:Generated minimal Python wrapper: docstring_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "c_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp', 'f90wrap_main.fpp']",
        "Command: f90wrap -m docstring_direct /tmp/tmp5k7m4j73/main.fpp /tmp/tmp5k7m4j73/f90wrap_main.fpp  --direct-c -v",
        "Generated C files: ['_docstring_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Preprocessed f90wrap_main.fpp -> f90wrap_main_processed.f90",
        "Found support module: docstring_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90 f90wrap_main_processed.f90 docstring_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _docstring_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _docstring_directmodule.o",
        "Failed to compile _docstring_directmodule.c: _docstring_directmodule.c:297:240: warning: unknown escape sequence: \u2018\\p\u2019\n  297 | static char wrap_doc_inside__doc__[] = \"=========================================================================== >  \\brief Doc inside  \\param[in,out] circle      t_circle to initialize  \\param[in]     radius      radius of the circle <\";\n      |                                                                                                                                                                          "
      ]
    },
    {
      "name": "elemental",
      "path": "/home/ert/code/f90wrap/examples/elemental",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char', '1': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dp': 'double',\n          'idp': 'double',\n          'isp': 'float'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpvbx6ao87/elemental_module.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpvbx6ao87/elemental_module.fpp\nDEBUG:f90wrap.parser:    module function checking sinc\nDEBUG:f90wrap.parser:    module function sinc\nDEBUG:f90wrap.parser:  module elemental_module\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking public symbol sinc\nDEBUG:f90wrap.transform:visiting Module(name=elemental_module)\nDEBUG:f90wrap.transform:visiting Module(name=elemental_module)\nINFO:f90wrap.transform:visiting Module(name=elemental_module) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _elemental_directmodule.c\nINFO:root:Generated minimal Python wrapper: elemental_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['elemental_module.fpp']",
        "Command: f90wrap -m elemental_direct /tmp/tmpvbx6ao87/elemental_module.fpp -k /tmp/tmpvbx6ao87/kind_map --direct-c -v",
        "Generated C files: ['_elemental_directmodule.c']",
        "Preprocessed elemental_module.fpp -> elemental_module_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c elemental_module_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _elemental_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _elemental_directmodule.o",
        "Linking: gcc -shared _elemental_directmodule.o elemental_module_processed.o -lgfortran -o _elemental_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "errorbinding",
      "path": "/home/ert/code/f90wrap/examples/errorbinding",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char', '1': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dp': 'double',\n          'idp': 'double',\n          'isp': 'float'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpg3uhv5ip/datatypes.fpp', '/tmp/tmpg3uhv5ip/parameters.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpg3uhv5ip/datatypes.fpp\nINFO:f90wrap.parser:marking module datatypes as default private\nINFO:f90wrap.parser:parser reading type typewithprocedure\nDEBUG:f90wrap.parser:parser reading type typewithprocedure bound procedures\nDEBUG:f90wrap.parser:found procedure binding init => init_procedure\nDEBUG:f90wrap.parser:found procedure binding info => info_procedure\nDEBUG:f90wrap.parser:    type typewithprocedure\nDEBUG:f90wrap.parser:    module subroutine checking init_procedure\nDEBUG:f90wrap.parser:    module subroutine init_procedure\nDEBUG:f90wrap.parser:    module subroutine checking info_procedure\nDEBUG:f90wrap.parser:    module subroutine info_procedure\nDEBUG:f90wrap.parser:    module subroutine checking constructor_typewithprocedure\nDEBUG:f90wrap.parser:    module subroutine constructor_typewithprocedure\nDEBUG:f90wrap.parser:    module subroutine checking info_typewithprocedure\nDEBUG:f90wrap.parser:    module subroutine info_typewithprocedure\nDEBUG:f90wrap.parser:  module datatypes\nDEBUG:f90wrap.parser:processing file /tmp/tmpg3uhv5ip/parameters.fpp\nINFO:f90wrap.parser:marking module parameters as default private\nDEBUG:f90wrap.parser:  module parameters\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type typewithprocedure defined in module datatypes\nDerived types detected in Fortran source files:\n{'class(typewithprocedure)': Type(name=typewithprocedure),\n 'type(typewithprocedure)': Type(name=typewithprocedure),\n 'typewithprocedure': Type(name=typewithprocedure)}\n\nClass name mapping:\n{'class(typewithprocedure)': 'typewithprocedure',\n 'type(typewithprocedure)': 'typewithprocedure',\n 'typewithprocedure': 'typewithprocedure'}\nModules for each type:\n{'datatypes': 'datatypes'}\nDEBUG:f90wrap.transform:Creating method for typewithprocedure from procedure init_procedure.\nDEBUG:f90wrap.transform:Creating method for typewithprocedure from procedure info_procedure.\nDEBUG:f90wrap.fortran:type typewithprocedure defined in module datatypes\nDEBUG:f90wrap.transform:marking private symbol info_procedure\nDEBUG:f90wrap.transform:marking private symbol init_procedure\nDEBUG:f90wrap.transform:removing private symbol info_procedure\nDEBUG:f90wrap.transform:removing private symbol init_procedure\nDEBUG:f90wrap.transform:visiting Module(name=datatypes)\nDEBUG:f90wrap.transform:visiting Type(name=typewithprocedure)\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nINFO:f90wrap.transform:adding missing constructor for typewithprocedure\nINFO:f90wrap.transform:adding missing destructor for typewithprocedure\nDEBUG:f90wrap.transform:visiting Module(name=datatypes)\nINFO:f90wrap.transform:visiting Module(name=datatypes) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=typewithprocedure)\nINFO:f90wrap.transform:visiting Type(name=typewithprocedure) found 1 constructors with names: ['typewithprocedure_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=parameters)\nINFO:f90wrap.transform:visiting Module(name=parameters) found 0 constructors with names: []\nDEBUG:f90wrap.transform:allocating arg \"this\" in typewithprocedure_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in typewithprocedure_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _errorbinding_directmodule.c\nINFO:root:Generated Fortran support module: errorbinding_direct_support.f90\nINFO:root:Generated minimal Python wrapper: errorbinding_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['datatypes.fpp', 'parameters.fpp']",
        "Command: f90wrap -m errorbinding_direct /tmp/tmpg3uhv5ip/datatypes.fpp /tmp/tmpg3uhv5ip/parameters.fpp -k /tmp/tmpg3uhv5ip/kind_map --direct-c -v",
        "Generated C files: ['_errorbinding_directmodule.c']",
        "Preprocessed datatypes.fpp -> datatypes_processed.f90",
        "Preprocessed parameters.fpp -> parameters_processed.f90",
        "Found support module: errorbinding_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c datatypes_processed.f90 parameters_processed.f90 errorbinding_direct_support.f90",
        "Fortran compilation failed: /home/ert/code/f90wrap/examples/errorbinding/datatypes.f90:3:5:\n\n    3 | use parameters, only: idp, isp\n      |     1\nFatal Error: Cannot open module file \u2018parameters.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\nerrorbinding_direct_support.f90:6:9:\n\n    6 |     use datatypes\n      |         1\nFatal Error: Cannot open module file \u2018datatypes.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\n"
      ]
    },
    {
      "name": "example2",
      "path": "/home/ert/code/f90wrap/examples/example2",
      "status": "SKIP",
      "f90wrap_output": "",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "No Fortran source files found"
      ]
    },
    {
      "name": "extends",
      "path": "/home/ert/code/f90wrap/examples/extends",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpv_h78_9b/testextends.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpv_h78_9b/testextends.fpp\nINFO:f90wrap.parser:marking module testextends_mod as default public\nINFO:f90wrap.parser:parser reading type Superclass\nDEBUG:f90wrap.parser:    type Superclass\nINFO:f90wrap.parser:parser reading type Subclass1\nDEBUG:f90wrap.parser:    type Subclass1\nINFO:f90wrap.parser:parser reading type Subclass2\nDEBUG:f90wrap.parser:    type Subclass2\nDEBUG:f90wrap.parser:  module testextends_mod\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type superclass defined in module testextends_mod\nDEBUG:f90wrap.fortran:type subclass1 defined in module testextends_mod\nDEBUG:f90wrap.fortran:type subclass2 defined in module testextends_mod\nDerived types detected in Fortran source files:\n{'class(subclass1)': Type(name=subclass1),\n 'class(subclass2)': Type(name=subclass2),\n 'class(superclass)': Type(name=superclass),\n 'subclass1': Type(name=subclass1),\n 'subclass2': Type(name=subclass2),\n 'superclass': Type(name=superclass),\n 'type(subclass1)': Type(name=subclass1),\n 'type(subclass2)': Type(name=subclass2),\n 'type(superclass)': Type(name=superclass)}\n\nClass name mapping:\n{'class(subclass1)': 'Subclass1',\n 'class(subclass2)': 'Subclass2',\n 'class(superclass)': 'Superclass',\n 'subclass1': 'Subclass1',\n 'subclass2': 'Subclass2',\n 'superclass': 'Superclass',\n 'type(subclass1)': 'Subclass1',\n 'type(subclass2)': 'Subclass2',\n 'type(superclass)': 'Superclass'}\nModules for each type:\n{'testextends_mod': 'testextends_mod'}\nDEBUG:f90wrap.fortran:type superclass defined in module testextends_mod\nDEBUG:f90wrap.fortran:type subclass1 defined in module testextends_mod\nDEBUG:f90wrap.fortran:type subclass2 defined in module testextends_mod\nDEBUG:f90wrap.transform:marking public symbol superclass\nDEBUG:f90wrap.transform:marking public symbol subclass1\nDEBUG:f90wrap.transform:marking public symbol subclass2\nDEBUG:f90wrap.transform:visiting Module(name=testextends_mod)\nDEBUG:f90wrap.transform:visiting Type(name=superclass)\nDEBUG:f90wrap.transform:visiting Type(name=subclass1)\nDEBUG:f90wrap.transform:visiting Type(name=subclass2)\nINFO:f90wrap.transform:adding missing constructor for superclass\nINFO:f90wrap.transform:adding missing constructor for subclass1\nINFO:f90wrap.transform:adding missing constructor for subclass2\nINFO:f90wrap.transform:adding missing destructor for superclass\nINFO:f90wrap.transform:adding missing destructor for subclass1\nINFO:f90wrap.transform:adding missing destructor for subclass2\nDEBUG:f90wrap.transform:visiting Module(name=testextends_mod)\nINFO:f90wrap.transform:visiting Module(name=testextends_mod) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=superclass)\nINFO:f90wrap.transform:visiting Type(name=superclass) found 1 constructors with names: ['superclass_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=subclass1)\nINFO:f90wrap.transform:visiting Type(name=subclass1) found 1 constructors with names: ['subclass1_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=subclass2)\nINFO:f90wrap.transform:visiting Type(name=subclass2) found 1 constructors with names: ['subclass2_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in superclass_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in superclass_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in subclass1_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in subclass1_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in subclass2_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in subclass2_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _extends_directmodule.c\nINFO:root:Generated Fortran support module: extends_direct_support.f90\nINFO:root:Generated minimal Python wrapper: extends_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['testextends.fpp']",
        "Command: f90wrap -m extends_direct /tmp/tmpv_h78_9b/testextends.fpp  --direct-c -v",
        "Generated C files: ['_extends_directmodule.c']",
        "Preprocessed testextends.fpp -> testextends_processed.f90",
        "Found support module: extends_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c testextends_processed.f90 extends_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _extends_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _extends_directmodule.o",
        "Linking: gcc -shared _extends_directmodule.o extends_direct_support.o testextends_processed.o -lgfortran -o _extends_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "fixed_1D_derived_type_array_argument",
      "path": "/home/ert/code/f90wrap/examples/fixed_1D_derived_type_array_argument",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmppbmco9ti/functions.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmppbmco9ti/functions.fpp\nINFO:f90wrap.parser:parser reading type test_type2\nDEBUG:f90wrap.parser:    type test_type2\nDEBUG:f90wrap.parser:    module subroutine checking test_routine4\nDEBUG:f90wrap.parser:        implicit type of \"x6\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module subroutine test_routine4\nDEBUG:f90wrap.parser:  module test_module\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type test_type2 defined in module test_module\nDerived types detected in Fortran source files:\n{'class(test_type2)': Type(name=test_type2),\n 'test_type2': Type(name=test_type2),\n 'type(test_type2)': Type(name=test_type2)}\n\nClass name mapping:\n{'class(test_type2)': 'test_type2',\n 'test_type2': 'test_type2',\n 'type(test_type2)': 'test_type2'}\nModules for each type:\n{'test_module': 'test_module'}\nDEBUG:f90wrap.fortran:type test_type2 defined in module test_module\nDEBUG:f90wrap.transform:marking public symbol test_type2\nDEBUG:f90wrap.transform:marking public symbol m\nDEBUG:f90wrap.transform:marking public symbol n\nDEBUG:f90wrap.transform:marking public symbol test_routine4\nDEBUG:f90wrap.transform:visiting Module(name=test_module)\nDEBUG:f90wrap.transform:visiting Type(name=test_type2)\nINFO:f90wrap.transform:adding missing constructor for test_type2\n",
      "f90wrap_error": "Traceback (most recent call last):\n  File \"/home/ert/code/.venv/lib/python3.13/site-packages/f90wrap/scripts/main.py\", line 357, in main\n    tree = tf.transform_to_generic_wrapper(tree,\n                                           types,\n    ...<11 lines>...\n                                           remove_optional_arguments,\n                                           force_public=force_public)\n  File \"/home/ert/code/.venv/lib/python3.13/site-packages/f90wrap/transform.py\", line 1399, in transform_to_generic_wrapper\n    tree = add_missing_constructors(tree)\n  File \"/home/ert/code/.venv/lib/python3.13/site-packages/f90wrap/transform.py\", line 865, in add_missing_constructors\n    if 'abstract' in node.attributes:\n                     ^^^^^^^^^^^^^^^\nAttributeError: 'Type' object has no attribute 'attributes'\nf90wrap: AttributeError(\"'Type' object has no attribute 'attributes'\")\n         for help use --help\nTraceback (most recent call last):\n  File \"/home/ert/code/.venv/bin/f90wrap\", line 7, in <module>\n    sys.exit(main())\n             ~~~~^^\n  File \"/home/ert/code/.venv/lib/python3.13/site-packages/f90wrap/scripts/main.py\", line 357, in main\n    tree = tf.transform_to_generic_wrapper(tree,\n                                           types,\n    ...<11 lines>...\n                                           remove_optional_arguments,\n                                           force_public=force_public)\n  File \"/home/ert/code/.venv/lib/python3.13/site-packages/f90wrap/transform.py\", line 1399, in transform_to_generic_wrapper\n    tree = add_missing_constructors(tree)\n  File \"/home/ert/code/.venv/lib/python3.13/site-packages/f90wrap/transform.py\", line 865, in add_missing_constructors\n    if 'abstract' in node.attributes:\n                     ^^^^^^^^^^^^^^^\nAttributeError: 'Type' object has no attribute 'attributes'\n",
      "test_output": "",
      "test_error": "",
      "error_category": "attribute_error",
      "notes": [
        "Using preprocessed files for f90wrap: ['functions.fpp']",
        "Command: f90wrap -m fixed_1D_derived_type_array_argument_direct /tmp/tmppbmco9ti/functions.fpp  --direct-c -v",
        "f90wrap failed with return code 1"
      ]
    },
    {
      "name": "fortran_oo",
      "path": "/home/ert/code/f90wrap/examples/fortran_oo",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpay4buq07/main-oo.fpp', '/tmp/tmpay4buq07/f90wrap_main-oo.fpp', '/tmp/tmpay4buq07/base_poly.fpp', '/tmp/tmpay4buq07/f90wrap_base_poly.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpay4buq07/main-oo.fpp\nINFO:f90wrap.parser:marking module m_geometry as default private\nINFO:f90wrap.parser:parser reading type Rectangle\nDEBUG:f90wrap.parser:parser reading type Rectangle bound procedures\nDEBUG:f90wrap.parser:found procedure binding perimeter => rectangle_perimeter\nDEBUG:f90wrap.parser:found procedure binding is_square => rectangle_is_square\nDEBUG:f90wrap.parser:found deferred procedure(abstract_area) binding area\nDEBUG:f90wrap.parser:    type Rectangle\nINFO:f90wrap.parser:parser reading type Square\nDEBUG:f90wrap.parser:parser reading type Square bound procedures\nDEBUG:f90wrap.parser:found procedure binding is_square => square_is_square\nDEBUG:f90wrap.parser:found procedure binding area => square_area\nDEBUG:f90wrap.parser:    type Square\nDEBUG:f90wrap.parser:    module function checking abstract_area\nDEBUG:f90wrap.parser:        implicit type of \"abstract_area\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    abstract interface \nDEBUG:f90wrap.parser:    interface Square\nINFO:f90wrap.parser:parser reading type Circle\nDEBUG:f90wrap.parser:parser reading type Circle bound procedures\nDEBUG:f90wrap.parser:found procedure binding area => circle_area\nDEBUG:f90wrap.parser:found procedure binding print => circle_print\nDEBUG:f90wrap.parser:found procedure binding obj_name => circle_obj_name\nDEBUG:f90wrap.parser:found procedure binding copy => circle_copy\nDEBUG:f90wrap.parser:found procedure binding private_method => circle_private\nDEBUG:f90wrap.parser:found procedure binding perimeter_4 => circle_perimeter_4\nDEBUG:f90wrap.parser:found procedure binding perimeter_8 => circle_perimeter_8\nDEBUG:f90wrap.parser:found generic binding perimeter =>  perimeter_8, perimeter_4\nDEBUG:f90wrap.parser:found final binding circle_free => circle_free\nDEBUG:f90wrap.parser:    type Circle\nINFO:f90wrap.parser:parser reading type Ball\nDEBUG:f90wrap.parser:parser reading type Ball bound procedures\nDEBUG:f90wrap.parser:found procedure binding volume => ball_volume\nDEBUG:f90wrap.parser:found procedure binding area => ball_area\nDEBUG:f90wrap.parser:found procedure binding private_method => ball_private\nDEBUG:f90wrap.parser:    type Ball\nDEBUG:f90wrap.parser:    interface Circle\nDEBUG:f90wrap.parser:    interface Ball\nDEBUG:f90wrap.parser:    module function checking construct_square\nDEBUG:f90wrap.parser:        implicit type of \"construct_square\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function construct_square\nDEBUG:f90wrap.parser:    module function checking construct_circle\nDEBUG:f90wrap.parser:        implicit type of \"construct_circle\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function construct_circle\nDEBUG:f90wrap.parser:    module function checking construct_ball\nDEBUG:f90wrap.parser:        implicit type of \"construct_ball\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function construct_ball\nDEBUG:f90wrap.parser:    module function checking get_circle_radius\nDEBUG:f90wrap.parser:        implicit type of \"get_circle_radius\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function get_circle_radius\nDEBUG:f90wrap.parser:    module function checking get_ball_radius\nDEBUG:f90wrap.parser:        implicit type of \"get_ball_radius\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function get_ball_radius\nDEBUG:f90wrap.parser:    module function checking circle_area\nDEBUG:f90wrap.parser:        implicit type of \"circle_area\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function circle_area\nDEBUG:f90wrap.parser:    module subroutine checking circle_print\nDEBUG:f90wrap.parser:    module subroutine circle_print\nDEBUG:f90wrap.parser:    module subroutine checking circle_obj_name\nDEBUG:f90wrap.parser:    module subroutine circle_obj_name\nDEBUG:f90wrap.parser:    module subroutine checking circle_copy\nDEBUG:f90wrap.parser:    module subroutine circle_copy\nDEBUG:f90wrap.parser:    module subroutine checking circle_private\nDEBUG:f90wrap.parser:    module subroutine circle_private\nDEBUG:f90wrap.parser:    module subroutine checking circle_free\nDEBUG:f90wrap.parser:    module subroutine circle_free\nDEBUG:f90wrap.parser:    module function checking ball_area\nDEBUG:f90wrap.parser:        implicit type of \"ball_area\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ball_area\nDEBUG:f90wrap.parser:    module function checking ball_volume\nDEBUG:f90wrap.parser:        implicit type of \"ball_volume\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function ball_volume\nDEBUG:f90wrap.parser:    module subroutine checking ball_private\nDEBUG:f90wrap.parser:    module subroutine ball_private\nDEBUG:f90wrap.parser:    module function checking circle_perimeter_4\nDEBUG:f90wrap.parser:        implicit type of \"circle_perimeter_4\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function circle_perimeter_4\nDEBUG:f90wrap.parser:    module function checking circle_perimeter_8\nDEBUG:f90wrap.parser:        implicit type of \"circle_perimeter_8\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function circle_perimeter_8\nDEBUG:f90wrap.parser:    module function checking rectangle_perimeter\nDEBUG:f90wrap.parser:        implicit type of \"rectangle_perimeter\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function rectangle_perimeter\nDEBUG:f90wrap.parser:    module function checking square_area\nDEBUG:f90wrap.parser:        implicit type of \"square_area\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function square_area\nDEBUG:f90wrap.parser:    module function checking rectangle_is_square\nDEBUG:f90wrap.parser:        implicit type of \"rectangle_is_square\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function rectangle_is_square\nDEBUG:f90wrap.parser:    module function checking square_is_square\nDEBUG:f90wrap.parser:        implicit type of \"square_is_square\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function square_is_square\nDEBUG:f90wrap.parser:  module m_geometry\nDEBUG:f90wrap.parser:processing file /tmp/tmpay4buq07/f90wrap_main-oo.fpp\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_rectangle__get__length\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_rectangle__set__length\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_rectangle__get__width\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_rectangle__set__width\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__perimeter__binding__rectangle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__is_square__binding__rectangle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__area__binding__rectangle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_base_poly__is_polygone__binding__polygone_rectangle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__construct_square\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__square_finalise\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__is_square__binding__square\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__area__binding__square\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__perimeter__binding__rectangle_square\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_base_poly__is_polygone__binding__polygone_rectang5400\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_circle__get__radius\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_circle__set__radius\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__construct_circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__area__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__print__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__obj_name__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__copy__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__private_method__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__perimeter_4__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__perimeter_8__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__circle_free__binding__circle\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__construct_ball\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__ball_finalise\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__volume__binding__ball\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__area__binding__ball\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__private_method__binding__ball\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__circle_print\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__circle_free\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__ball_area\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__get_ball_radius\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__circle_copy\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__ball_volume\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__get_circle_radius\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__circle_obj_name\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__circle_area\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_geometry__get__pi\nDEBUG:f90wrap.parser:processing file /tmp/tmpay4buq07/base_poly.fpp\nINFO:f90wrap.parser:marking module m_base_poly as default private\nINFO:f90wrap.parser:parser reading type Polygone\nDEBUG:f90wrap.parser:parser reading type Polygone bound procedures\nDEBUG:f90wrap.parser:found procedure binding is_polygone => polygone_is_polygone\nDEBUG:f90wrap.parser:    type Polygone\nDEBUG:f90wrap.parser:    module function checking polygone_is_polygone\nDEBUG:f90wrap.parser:        implicit type of \"polygone_is_polygone\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function polygone_is_polygone\nDEBUG:f90wrap.parser:  module m_base_poly\nDEBUG:f90wrap.parser:processing file /tmp/tmpay4buq07/f90wrap_base_poly.fpp\nDEBUG:f90wrap.parser:    module subroutine checking f90wrap_m_base_poly__is_polygone__binding__polygone\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type rectangle defined in module m_geometry\nDEBUG:f90wrap.fortran:type square defined in module m_geometry\nDEBUG:f90wrap.fortran:type circle defined in module m_geometry\nDEBUG:f90wrap.fortran:type ball defined in module m_geometry\nDEBUG:f90wrap.fortran:type polygone defined in module m_base_poly\nDerived types detected in Fortran source files:\n{'ball': Type(name=ball),\n 'circle': Type(name=circle),\n 'class(ball)': Type(name=ball),\n 'class(circle)': Type(name=circle),\n 'class(polygone)': Type(name=polygone),\n 'class(rectangle)': Type(name=rectangle),\n 'class(square)': Type(name=square),\n 'polygone': Type(name=polygone),\n 'rectangle': Type(name=rectangle),\n 'square': Type(name=square),\n 'type(ball)': Type(name=ball),\n 'type(circle)': Type(name=circle),\n 'type(polygone)': Type(name=polygone),\n 'type(rectangle)': Type(name=rectangle),\n 'type(square)': Type(name=square)}\n\nClass name mapping:\n{'ball': 'Ball',\n 'circle': 'Circle',\n 'class(ball)': 'Ball',\n 'class(circle)': 'Circle',\n 'class(polygone)': 'Polygone',\n 'class(rectangle)': 'Rectangle',\n 'class(square)': 'Square',\n 'polygone': 'Polygone',\n 'rectangle': 'Rectangle',\n 'square': 'Square',\n 'type(ball)': 'Ball',\n 'type(circle)': 'Circle',\n 'type(polygone)': 'Polygone',\n 'type(rectangle)': 'Rectangle',\n 'type(square)': 'Square'}\nModules for each type:\n{'m_base_poly': 'm_base_poly', 'm_geometry': 'm_geometry'}\nDEBUG:f90wrap.transform:Creating method for rectangle from procedure rectangle_perimeter.\nDEBUG:f90wrap.transform:Creating method for rectangle from procedure rectangle_is_square.\nDEBUG:f90wrap.transform:Creating method for rectangle from procedure abstract_area.\nDEBUG:f90wrap.transform:Creating method for square from procedure square_is_square.\nDEBUG:f90wrap.transform:Creating method for square from procedure square_area.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_area.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_print.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_obj_name.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_copy.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_private.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_perimeter_4.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_perimeter_8.\nDEBUG:f90wrap.transform:Creating method for circle from procedure circle_free.\nDEBUG:f90wrap.transform:Marking method circle_free__binding__circle as destructor for circle\nDEBUG:f90wrap.transform:Creating method for ball from procedure ball_volume.\nDEBUG:f90wrap.transform:Creating method for ball from procedure ball_area.\nDEBUG:f90wrap.transform:Creating method for ball from procedure ball_private.\nDEBUG:f90wrap.transform:Creating method for polygone from procedure polygone_is_polygone.\nDEBUG:f90wrap.fortran:type rectangle defined in module m_geometry\nDEBUG:f90wrap.fortran:type square defined in module m_geometry\nDEBUG:f90wrap.fortran:type circle defined in module m_geometry\nDEBUG:f90wrap.fortran:type ball defined in module m_geometry\nDEBUG:f90wrap.fortran:type polygone defined in module m_base_poly\nDEBUG:f90wrap.transform:Move interface square into type square and mark constructor\nDEBUG:f90wrap.transform:Move interface circle into type circle and mark constructor\nDEBUG:f90wrap.transform:Move interface ball into type ball and mark constructor\nDEBUG:f90wrap.transform:marking public symbol polygone\nDEBUG:f90wrap.transform:marking private symbol polygone_is_polygone\nDEBUG:f90wrap.transform:marking public symbol rectangle\nDEBUG:f90wrap.transform:marking public symbol square\nDEBUG:f90wrap.transform:marking private symbol construct_square\nDEBUG:f90wrap.transform:marking public symbol circle\nDEBUG:f90wrap.transform:marking private symbol construct_circle\nDEBUG:f90wrap.transform:marking public symbol ball\nDEBUG:f90wrap.transform:marking private symbol construct_ball\nDEBUG:f90wrap.transform:marking private symbol rectangle_perimeter\nDEBUG:f90wrap.transform:marking private symbol ball_private\nDEBUG:f90wrap.transform:marking private symbol rectangle_is_square\nDEBUG:f90wrap.transform:marking private symbol square_area\nDEBUG:f90wrap.transform:marking private symbol circle_perimeter_8\nDEBUG:f90wrap.transform:marking private symbol square_is_square\nDEBUG:f90wrap.transform:marking private symbol circle_private\nDEBUG:f90wrap.transform:marking private symbol circle_perimeter_4\nDEBUG:f90wrap.transform:marking private symbol \nDEBUG:f90wrap.transform:removing private symbol polygone_is_polygone\nDEBUG:f90wrap.transform:removing private symbol rectangle_perimeter\nDEBUG:f90wrap.transform:removing private symbol ball_private\nDEBUG:f90wrap.transform:removing private symbol rectangle_is_square\nDEBUG:f90wrap.transform:removing private symbol square_area\nDEBUG:f90wrap.transform:removing private symbol circle_perimeter_8\nDEBUG:f90wrap.transform:removing private symbol square_is_square\nDEBUG:f90wrap.transform:removing private symbol circle_private\nDEBUG:f90wrap.transform:removing private symbol circle_perimeter_4\nDEBUG:f90wrap.transform:removing private symbol on interface \nINFO:f90wrap.transform:setting call_name of construct_square to square\nINFO:f90wrap.transform:setting call_name of construct_circle to circle\nINFO:f90wrap.transform:setting call_name of construct_ball to ball\nDEBUG:f90wrap.transform:collapsing single-component interface construct_square\nDEBUG:f90wrap.transform:collapsing single-component interface construct_circle\nDEBUG:f90wrap.transform:collapsing single-component interface construct_ball\nDEBUG:f90wrap.transform:visiting Module(name=m_base_poly)\nDEBUG:f90wrap.transform:visiting Type(name=polygone)\nDEBUG:f90wrap.transform:visiting Module(name=m_geometry)\nDEBUG:f90wrap.transform:visiting Type(name=rectangle)\nDEBUG:f90wrap.transform:visiting Type(name=square)\nDEBUG:f90wrap.transform:visiting Type(name=circle)\nDEBUG:f90wrap.transform:visiting Type(name=ball)\nINFO:f90wrap.transform:adding missing constructor for polygone\nINFO:f90wrap.transform:adding missing constructor for rectangle\nINFO:f90wrap.transform:found constructor construct_square\nINFO:f90wrap.transform:found constructor construct_circle\nINFO:f90wrap.transform:found constructor construct_ball\nINFO:f90wrap.transform:adding missing destructor for polygone\nINFO:f90wrap.transform:adding missing destructor for rectangle\nINFO:f90wrap.transform:adding missing destructor for square\nINFO:f90wrap.transform:found destructor circle_free\nINFO:f90wrap.transform:adding missing destructor for ball\nDEBUG:f90wrap.transform:visiting Module(name=m_base_poly)\nINFO:f90wrap.transform:visiting Module(name=m_base_poly) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=polygone)\nINFO:f90wrap.transform:visiting Type(name=polygone) found 1 constructors with names: ['polygone_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=m_geometry)\nINFO:f90wrap.transform:visiting Module(name=m_geometry) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=rectangle)\nINFO:f90wrap.transform:visiting Type(name=rectangle) found 1 constructors with names: ['rectangle_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=square)\nINFO:f90wrap.transform:visiting Type(name=square) found 1 constructors with names: ['construct_square']\nDEBUG:f90wrap.transform:visiting Type(name=circle)\nINFO:f90wrap.transform:visiting Type(name=circle) found 1 constructors with names: ['construct_circle']\nDEBUG:f90wrap.transform:visiting Type(name=ball)\nINFO:f90wrap.transform:visiting Type(name=ball) found 1 constructors with names: ['construct_ball']\nDEBUG:f90wrap.transform:allocating arg \"this\" in polygone_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in polygone_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in rectangle_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in rectangle_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_construct_square\" in construct_square\nDEBUG:f90wrap.transform:deallocating arg \"this\" in square_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_construct_circle\" in construct_circle\nDEBUG:f90wrap.transform:allocating arg \"ret_construct_ball\" in construct_ball\nDEBUG:f90wrap.transform:deallocating arg \"this\" in ball_finalise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in circle_free__binding__circle\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _fortran_oo_directmodule.c\nINFO:root:Generated Fortran support module: fortran_oo_direct_support.f90\nINFO:root:Generated minimal Python wrapper: fortran_oo_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['main-oo.fpp', 'f90wrap_main-oo.fpp', 'base_poly.fpp', 'f90wrap_base_poly.fpp']",
        "Command: f90wrap -m fortran_oo_direct /tmp/tmpay4buq07/main-oo.fpp /tmp/tmpay4buq07/f90wrap_main-oo.fpp /tmp/tmpay4buq07/base_poly.fpp /tmp/tmpay4buq07/f90wrap_base_poly.fpp  --direct-c -v",
        "Generated C files: ['_fortran_oo_directmodule.c']",
        "Preprocessed main-oo.fpp -> main-oo_processed.f90",
        "Preprocessed f90wrap_main-oo.fpp -> f90wrap_main-oo_processed.f90",
        "Preprocessed base_poly.fpp -> base_poly_processed.f90",
        "Preprocessed f90wrap_base_poly.fpp -> f90wrap_base_poly_processed.f90",
        "Found support module: fortran_oo_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c main-oo_processed.f90 f90wrap_main-oo_processed.f90 base_poly_processed.f90 f90wrap_base_poly_processed.f90 fortran_oo_direct_support.f90",
        "Fortran compilation failed: /home/ert/code/f90wrap/examples/fortran_oo/f90wrap_main-oo.f90:411:20:\n\n  411 |     ret_perimeter = this_ptr%p%obj%perimeter_8(radius=radius)\n      |                    1\nError: Type mismatch in argument \u2018radius\u2019 at (1); passed REAL(4) to REAL(8)\n"
      ]
    },
    {
      "name": "intent_out_size",
      "path": "/home/ert/code/f90wrap/examples/intent_out_size",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpp_0xklyo/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpp_0xklyo/main.fpp\nINFO:f90wrap.parser:marking module m_intent_out as default public\nDEBUG:f90wrap.parser:    module subroutine checking interpolation\nDEBUG:f90wrap.parser:    module subroutine interpolation\nDEBUG:f90wrap.parser:  module m_intent_out\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking public symbol interpolation\nDEBUG:f90wrap.transform:visiting Module(name=m_intent_out)\nDEBUG:f90wrap.transform:visiting Module(name=m_intent_out)\nINFO:f90wrap.transform:visiting Module(name=m_intent_out) found 0 constructors with names: []\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to interpolation\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2), Argument(name=f90wrap_n3)] to interpolation\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n4), Argument(name=f90wrap_n5)] to interpolation\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _intent_out_size_directmodule.c\nINFO:root:Generated minimal Python wrapper: intent_out_size_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m intent_out_size_direct /tmp/tmpp_0xklyo/main.fpp  --direct-c -v",
        "Generated C files: ['_intent_out_size_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _intent_out_size_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _intent_out_size_directmodule.o",
        "Linking: gcc -shared _intent_out_size_directmodule.o main_processed.o -lgfortran -o _intent_out_size_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "interface",
      "path": "/home/ert/code/f90wrap/examples/interface",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpn7710_rq/example.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpn7710_rq/example.fpp\nINFO:f90wrap.parser:marking module class_example as default private\nDEBUG:f90wrap.parser:    interface return_example\nINFO:f90wrap.parser:parser reading type Example\nDEBUG:f90wrap.parser:    type Example\nDEBUG:f90wrap.parser:    module function checking return_example_first\nDEBUG:f90wrap.parser:        implicit type of \"return_example_first\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_example_first\nDEBUG:f90wrap.parser:    module function checking return_example_second\nDEBUG:f90wrap.parser:        implicit type of \"return_example_second\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_example_second\nDEBUG:f90wrap.parser:    module function checking return_example_third\nDEBUG:f90wrap.parser:        implicit type of \"return_example_third\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_example_third\nDEBUG:f90wrap.parser:  module class_example\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type example defined in module class_example\nDerived types detected in Fortran source files:\n{'class(example)': Type(name=example),\n 'example': Type(name=example),\n 'type(example)': Type(name=example)}\n\nClass name mapping:\n{'class(example)': 'Example', 'example': 'Example', 'type(example)': 'Example'}\nModules for each type:\n{'class_example': 'class_example'}\nDEBUG:f90wrap.fortran:type example defined in module class_example\nDEBUG:f90wrap.transform:marking private symbol this\nDEBUG:f90wrap.transform:marking private symbol return_example_second\nDEBUG:f90wrap.transform:marking private symbol return_example_first\nDEBUG:f90wrap.transform:marking private symbol return_example_third\nDEBUG:f90wrap.transform:removing private symbol this\nINFO:f90wrap.transform:setting call_name of return_example_second to return_example\nINFO:f90wrap.transform:setting call_name of return_example_first to return_example\nINFO:f90wrap.transform:setting call_name of return_example_third to return_example\nDEBUG:f90wrap.transform:visiting Module(name=class_example)\nDEBUG:f90wrap.transform:visiting Type(name=example)\nINFO:f90wrap.transform:adding missing constructor for example\nINFO:f90wrap.transform:adding missing destructor for example\nDEBUG:f90wrap.transform:visiting Module(name=class_example)\nINFO:f90wrap.transform:visiting Module(name=class_example) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=example)\nINFO:f90wrap.transform:visiting Type(name=example) found 1 constructors with names: ['example_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in example_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in example_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_instance\" in return_example_second\nDEBUG:f90wrap.transform:allocating arg \"ret_instance\" in return_example_first\nDEBUG:f90wrap.transform:allocating arg \"ret_instance\" in return_example_third\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _interface_directmodule.c\nINFO:root:Generated Fortran support module: interface_direct_support.f90\nINFO:root:Generated minimal Python wrapper: interface_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['example.fpp']",
        "Command: f90wrap -m interface_direct /tmp/tmpn7710_rq/example.fpp  --direct-c -v",
        "Generated C files: ['_interface_directmodule.c']",
        "Preprocessed example.fpp -> example_processed.f90",
        "Found support module: interface_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c example_processed.f90 interface_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _interface_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _interface_directmodule.o",
        "Linking: gcc -shared _interface_directmodule.o interface_direct_support.o example_processed.o -lgfortran -o _interface_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "issue105_function_definition_with_empty_lines",
      "path": "/home/ert/code/f90wrap/examples/issue105_function_definition_with_empty_lines",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp2rwkyz2k/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp2rwkyz2k/main.fpp\nINFO:f90wrap.parser:marking module itestit as default private\nDEBUG:f90wrap.parser:    module subroutine checking testit1\nDEBUG:f90wrap.parser:    module subroutine testit1\nDEBUG:f90wrap.parser:    module subroutine checking testit2\nDEBUG:f90wrap.parser:    module subroutine testit2\nDEBUG:f90wrap.parser:  module itestit\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:visiting Module(name=itestit)\nDEBUG:f90wrap.transform:visiting Module(name=itestit)\nINFO:f90wrap.transform:visiting Module(name=itestit) found 0 constructors with names: []\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to testit2\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to testit1\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue105_function_definition_with_empty_lines_directmodule.c\nINFO:root:Generated minimal Python wrapper: issue105_function_definition_with_empty_lines_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m issue105_function_definition_with_empty_lines_direct /tmp/tmp2rwkyz2k/main.fpp  --direct-c -v",
        "Generated C files: ['_issue105_function_definition_with_empty_lines_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _issue105_function_definition_with_empty_lines_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _issue105_function_definition_with_empty_lines_directmodule.o",
        "Linking: gcc -shared _issue105_function_definition_with_empty_lines_directmodule.o main_processed.o -lgfortran -o _issue105_function_definition_with_empty_lines_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "issue206_subroutine_oldstyle",
      "path": "/home/ert/code/f90wrap/examples/issue206_subroutine_oldstyle",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp5whfrnmd/subroutine_oldstyle.f'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp5whfrnmd/subroutine_oldstyle.f\nDEBUG:f90wrap.parser:    module subroutine checking routine_with_oldstyle_asterisk\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue206_subroutine_oldstyle_directmodule.c\nINFO:root:Generated minimal Python wrapper: issue206_subroutine_oldstyle_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using source files for f90wrap: ['subroutine_oldstyle.f']",
        "Command: f90wrap -m issue206_subroutine_oldstyle_direct /tmp/tmp5whfrnmd/subroutine_oldstyle.f  --direct-c -v",
        "Generated C files: ['_issue206_subroutine_oldstyle_directmodule.c']",
        "Compiling Fortran: gfortran -fPIC -c subroutine_oldstyle.f",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _issue206_subroutine_oldstyle_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _issue206_subroutine_oldstyle_directmodule.o",
        "Linking: gcc -shared _issue206_subroutine_oldstyle_directmodule.o subroutine_oldstyle.o -lgfortran -o _issue206_subroutine_oldstyle_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "issue227_allocatable",
      "path": "/home/ert/code/f90wrap/examples/issue227_allocatable",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp3cwlllik/alloc_output.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp3cwlllik/alloc_output.fpp\nINFO:f90wrap.parser:parser reading type alloc_output_type\nDEBUG:f90wrap.parser:    type alloc_output_type\nDEBUG:f90wrap.parser:    module function checking alloc_output_type_func\nDEBUG:f90wrap.parser:        implicit type of \"alloc_output_type_func\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function alloc_output_type_func\nDEBUG:f90wrap.parser:    module function checking alloc_output_intrinsic_func\nDEBUG:f90wrap.parser:        implicit type of \"alloc_output_intrinsic_func\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function alloc_output_intrinsic_func\nDEBUG:f90wrap.parser:    module function checking alloc_output_array_func\nDEBUG:f90wrap.parser:        implicit type of \"alloc_output_array_func\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function alloc_output_array_func\nDEBUG:f90wrap.parser:    module subroutine checking noalloc_output_subroutine\nDEBUG:f90wrap.parser:    module subroutine noalloc_output_subroutine\nDEBUG:f90wrap.parser:  module alloc_output\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type alloc_output_type defined in module alloc_output\nDerived types detected in Fortran source files:\n{'alloc_output_type': Type(name=alloc_output_type),\n 'class(alloc_output_type)': Type(name=alloc_output_type),\n 'type(alloc_output_type)': Type(name=alloc_output_type)}\n\nClass name mapping:\n{'alloc_output_type': 'alloc_output_type',\n 'class(alloc_output_type)': 'alloc_output_type',\n 'type(alloc_output_type)': 'alloc_output_type'}\nModules for each type:\n{'alloc_output': 'alloc_output'}\nDEBUG:f90wrap.fortran:type alloc_output_type defined in module alloc_output\nDEBUG:f90wrap.transform:marking public symbol alloc_output_type\nDEBUG:f90wrap.transform:marking public symbol noalloc_output_subroutine\nDEBUG:f90wrap.transform:marking public symbol alloc_output_intrinsic_func\nDEBUG:f90wrap.transform:marking public symbol alloc_output_array_func\nDEBUG:f90wrap.transform:marking public symbol alloc_output_type_func\nWARNING:f90wrap.transform:removing routine alloc_output_intrinsic_func due to allocatable intrinsic type arguments\nWARNING:f90wrap.transform:removing routine alloc_output_array_func due to allocatable intrinsic type arguments\nDEBUG:f90wrap.transform:visiting Module(name=alloc_output)\nDEBUG:f90wrap.transform:visiting Type(name=alloc_output_type)\nINFO:f90wrap.transform:adding missing constructor for alloc_output_type\nINFO:f90wrap.transform:adding missing destructor for alloc_output_type\nDEBUG:f90wrap.transform:visiting Module(name=alloc_output)\nINFO:f90wrap.transform:visiting Module(name=alloc_output) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=alloc_output_type)\nINFO:f90wrap.transform:visiting Type(name=alloc_output_type) found 1 constructors with names: ['alloc_output_type_initialise']\nDEBUG:f90wrap.transform:allocating arg \"ret_out\" in alloc_output_type_func\nDEBUG:f90wrap.transform:allocating arg \"this\" in alloc_output_type_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in alloc_output_type_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue227_allocatable_directmodule.c\nINFO:root:Generated Fortran support module: issue227_allocatable_direct_support.f90\nINFO:root:Generated minimal Python wrapper: issue227_allocatable_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['alloc_output.fpp']",
        "Command: f90wrap -m issue227_allocatable_direct /tmp/tmp3cwlllik/alloc_output.fpp  --direct-c -v",
        "Generated C files: ['_issue227_allocatable_directmodule.c']",
        "Preprocessed alloc_output.fpp -> alloc_output_processed.f90",
        "Found support module: issue227_allocatable_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c alloc_output_processed.f90 issue227_allocatable_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _issue227_allocatable_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _issue227_allocatable_directmodule.o",
        "Linking: gcc -shared _issue227_allocatable_directmodule.o issue227_allocatable_direct_support.o alloc_output_processed.o -lgfortran -o _issue227_allocatable_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "issue235_allocatable_classes",
      "path": "/home/ert/code/f90wrap/examples/issue235_allocatable_classes",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp9z15zf3c/myclass_factory.fpp', '/tmp/tmp9z15zf3c/mytype.fpp', '/tmp/tmp9z15zf3c/myclass.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp9z15zf3c/myclass_factory.fpp\nDEBUG:f90wrap.parser:    module function checking myclass_create\nDEBUG:f90wrap.parser:        implicit type of \"myclass_create\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function myclass_create\nDEBUG:f90wrap.parser:  module myclass_factory\nDEBUG:f90wrap.parser:processing file /tmp/tmp9z15zf3c/mytype.fpp\nINFO:f90wrap.parser:parser reading type mytype_t\nDEBUG:f90wrap.parser:parser reading type mytype_t bound procedures\nDEBUG:f90wrap.parser:found final binding mytype_destroy => mytype_destroy\nDEBUG:f90wrap.parser:    type mytype_t\nDEBUG:f90wrap.parser:    module function checking mytype_create\nDEBUG:f90wrap.parser:        implicit type of \"mytype_create\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function mytype_create\nDEBUG:f90wrap.parser:    module subroutine checking mytype_destroy\nDEBUG:f90wrap.parser:    module subroutine mytype_destroy\nDEBUG:f90wrap.parser:  module mytype\nDEBUG:f90wrap.parser:processing file /tmp/tmp9z15zf3c/myclass.fpp\nINFO:f90wrap.parser:parser reading type myclass_t\nDEBUG:f90wrap.parser:parser reading type myclass_t bound procedures\nDEBUG:f90wrap.parser:found procedure binding get_val => myclass_get_val\nDEBUG:f90wrap.parser:found procedure binding set_val => myclass_set_val\nDEBUG:f90wrap.parser:found final binding myclass_destroy => myclass_destroy\nDEBUG:f90wrap.parser:    type myclass_t\nDEBUG:f90wrap.parser:    module subroutine checking myclass_get_val\nDEBUG:f90wrap.parser:    module subroutine myclass_get_val\nDEBUG:f90wrap.parser:    module subroutine checking myclass_set_val\nDEBUG:f90wrap.parser:    module subroutine myclass_set_val\nDEBUG:f90wrap.parser:    module subroutine checking myclass_destroy\nDEBUG:f90wrap.parser:    module subroutine myclass_destroy\nDEBUG:f90wrap.parser:  module myclass\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type mytype_t defined in module mytype\nDEBUG:f90wrap.fortran:type myclass_t defined in module myclass\nDerived types detected in Fortran source files:\n{'class(myclass_t)': Type(name=myclass_t),\n 'class(mytype_t)': Type(name=mytype_t),\n 'myclass_t': Type(name=myclass_t),\n 'mytype_t': Type(name=mytype_t),\n 'type(myclass_t)': Type(name=myclass_t),\n 'type(mytype_t)': Type(name=mytype_t)}\n\nClass name mapping:\n{'class(myclass_t)': 'myclass_t',\n 'class(mytype_t)': 'mytype_t',\n 'myclass_t': 'myclass_t',\n 'mytype_t': 'mytype_t',\n 'type(myclass_t)': 'myclass_t',\n 'type(mytype_t)': 'mytype_t'}\nModules for each type:\n{'myclass': 'myclass', 'mytype': 'mytype'}\nDEBUG:f90wrap.transform:Creating method for mytype_t from procedure mytype_destroy.\nDEBUG:f90wrap.transform:Marking method mytype_destroy__binding__mytype_t as destructor for mytype_t\nDEBUG:f90wrap.transform:Creating method for myclass_t from procedure myclass_get_val.\nDEBUG:f90wrap.transform:Creating method for myclass_t from procedure myclass_set_val.\nDEBUG:f90wrap.transform:Creating method for myclass_t from procedure myclass_destroy.\nDEBUG:f90wrap.transform:Marking method myclass_destroy__binding__myclass_t as destructor for myclass_t\nDEBUG:f90wrap.fortran:type mytype_t defined in module mytype\nDEBUG:f90wrap.fortran:type myclass_t defined in module myclass\nDEBUG:f90wrap.transform:marking public symbol myclass_create\nDEBUG:f90wrap.transform:marking public symbol mytype_t\nDEBUG:f90wrap.transform:marking public symbol create_count\nDEBUG:f90wrap.transform:marking public symbol destroy_count\nDEBUG:f90wrap.transform:marking public symbol mytype_create\nDEBUG:f90wrap.transform:marking public symbol mytype_destroy\nDEBUG:f90wrap.transform:marking public symbol myclass_t\nDEBUG:f90wrap.transform:marking public symbol create_count\nDEBUG:f90wrap.transform:marking public symbol destroy_count\nDEBUG:f90wrap.transform:marking public symbol myclass_destroy\nDEBUG:f90wrap.transform:marking public symbol myclass_set_val\nDEBUG:f90wrap.transform:marking public symbol myclass_get_val\nDEBUG:f90wrap.transform:visiting Module(name=myclass_factory)\nDEBUG:f90wrap.transform:visiting Module(name=mytype)\nDEBUG:f90wrap.transform:visiting Type(name=mytype_t)\nDEBUG:f90wrap.transform:visiting Module(name=myclass)\nDEBUG:f90wrap.transform:visiting Type(name=myclass_t)\nINFO:f90wrap.transform:adding missing constructor for mytype_t\nINFO:f90wrap.transform:adding missing constructor for myclass_t\nINFO:f90wrap.transform:found destructor mytype_destroy\nINFO:f90wrap.transform:found destructor myclass_destroy\nDEBUG:f90wrap.transform:visiting Module(name=myclass_factory)\nINFO:f90wrap.transform:visiting Module(name=myclass_factory) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Module(name=mytype)\nINFO:f90wrap.transform:visiting Module(name=mytype) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=mytype_t)\nINFO:f90wrap.transform:visiting Type(name=mytype_t) found 1 constructors with names: ['mytype_t_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=myclass)\nINFO:f90wrap.transform:visiting Module(name=myclass) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=myclass_t)\nINFO:f90wrap.transform:visiting Type(name=myclass_t) found 1 constructors with names: ['myclass_t_initialise']\nDEBUG:f90wrap.transform:allocating arg \"ret_myobject\" in myclass_create\nDEBUG:f90wrap.transform:allocating arg \"ret_self\" in mytype_create\nDEBUG:f90wrap.transform:allocating arg \"this\" in mytype_t_initialise\nDEBUG:f90wrap.transform:allocating arg \"this\" in myclass_t_initialise\nDEBUG:f90wrap.transform:deallocating arg \"self\" in mytype_destroy__binding__mytype_t\nDEBUG:f90wrap.transform:deallocating arg \"self\" in myclass_destroy__binding__myclass_t\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue235_allocatable_classes_directmodule.c\nINFO:root:Generated Fortran support module: issue235_allocatable_classes_direct_support.f90\nINFO:root:Generated minimal Python wrapper: issue235_allocatable_classes_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['myclass_factory.fpp', 'mytype.fpp', 'myclass.fpp']",
        "Command: f90wrap -m issue235_allocatable_classes_direct /tmp/tmp9z15zf3c/myclass_factory.fpp /tmp/tmp9z15zf3c/mytype.fpp /tmp/tmp9z15zf3c/myclass.fpp  --direct-c -v",
        "Generated C files: ['_issue235_allocatable_classes_directmodule.c']",
        "Preprocessed myclass_factory.fpp -> myclass_factory_processed.f90",
        "Preprocessed mytype.fpp -> mytype_processed.f90",
        "Preprocessed myclass.fpp -> myclass_processed.f90",
        "Found support module: issue235_allocatable_classes_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c myclass_factory_processed.f90 mytype_processed.f90 myclass_processed.f90 issue235_allocatable_classes_direct_support.f90",
        "Fortran compilation failed: /home/ert/code/f90wrap/examples/issue235_allocatable_classes/myclass_factory.f90:3:5:\n\n    3 | use myclass, only: myclass_t, create_count\n      |     1\nFatal Error: Cannot open module file \u2018myclass.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\nissue235_allocatable_classes_direct_support.f90:6:9:\n\n    6 |     use myclass_factory\n      |         1\nFatal Error: Cannot open module file \u2018myclass_factory.mod\u2019 for reading at (1): No such file or directory\ncompilation termin"
      ]
    },
    {
      "name": "issue254_getter",
      "path": "/home/ert/code/f90wrap/examples/issue254_getter",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpaf3jgcnz/KIMDispersion_Horton.fpp', '/tmp/tmpaf3jgcnz/KIMDispersionEquation.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpaf3jgcnz/KIMDispersion_Horton.fpp\nINFO:f90wrap.parser:parser reading type KIMDispersion_Horton\nDEBUG:f90wrap.parser:parser reading type KIMDispersion_Horton bound procedures\nDEBUG:f90wrap.parser:found procedure binding initialize => initialize_kimdispersion_horton\nDEBUG:f90wrap.parser:    type KIMDispersion_Horton\nDEBUG:f90wrap.parser:    module subroutine checking initialize_KIMDispersion_Horton\nDEBUG:f90wrap.parser:    module subroutine initialize_KIMDispersion_Horton\nDEBUG:f90wrap.parser:  module KIMDispersion_Horton_module\nDEBUG:f90wrap.parser:processing file /tmp/tmpaf3jgcnz/KIMDispersionEquation.fpp\nINFO:f90wrap.parser:parser reading type OptionsType\nDEBUG:f90wrap.parser:    type OptionsType\nINFO:f90wrap.parser:parser reading type KIMDispersionEquation\nDEBUG:f90wrap.parser:parser reading type KIMDispersionEquation bound procedures\nDEBUG:f90wrap.parser:found deferred procedure(initialize_interface) binding initialize\nDEBUG:f90wrap.parser:    type KIMDispersionEquation\nDEBUG:f90wrap.parser:    module subroutine checking initialize_interface\nDEBUG:f90wrap.parser:    abstract interface \nDEBUG:f90wrap.parser:  module KIMDispersionEquation_module\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type kimdispersion_horton defined in module kimdispersion_horton_module\nDEBUG:f90wrap.fortran:type optionstype defined in module kimdispersionequation_module\nDEBUG:f90wrap.fortran:type kimdispersionequation defined in module kimdispersionequation_module\nDerived types detected in Fortran source files:\n{'class(kimdispersion_horton)': Type(name=kimdispersion_horton),\n 'class(kimdispersionequation)': Type(name=kimdispersionequation),\n 'class(optionstype)': Type(name=optionstype),\n 'kimdispersion_horton': Type(name=kimdispersion_horton),\n 'kimdispersionequation': Type(name=kimdispersionequation),\n 'optionstype': Type(name=optionstype),\n 'type(kimdispersion_horton)': Type(name=kimdispersion_horton),\n 'type(kimdispersionequation)': Type(name=kimdispersionequation),\n 'type(optionstype)': Type(name=optionstype)}\n\nClass name mapping:\n{'class(kimdispersion_horton)': 'KIMDispersion_Horton',\n 'class(kimdispersionequation)': 'KIMDispersionEquation',\n 'class(optionstype)': 'OptionsType',\n 'kimdispersion_horton': 'KIMDispersion_Horton',\n 'kimdispersionequation': 'KIMDispersionEquation',\n 'optionstype': 'OptionsType',\n 'type(kimdispersion_horton)': 'KIMDispersion_Horton',\n 'type(kimdispersionequation)': 'KIMDispersionEquation',\n 'type(optionstype)': 'OptionsType'}\nModules for each type:\n{'kimdispersion_horton_module': 'kimdispersion_horton_module',\n 'kimdispersionequation_module': 'kimdispersionequation_module'}\nDEBUG:f90wrap.transform:Creating method for kimdispersion_horton from procedure initialize_kimdispersion_horton.\nDEBUG:f90wrap.transform:Creating method for kimdispersionequation from procedure initialize_interface.\nDEBUG:f90wrap.fortran:type kimdispersion_horton defined in module kimdispersion_horton_module\nDEBUG:f90wrap.fortran:type optionstype defined in module kimdispersionequation_module\nDEBUG:f90wrap.fortran:type kimdispersionequation defined in module kimdispersionequation_module\nDEBUG:f90wrap.transform:marking public symbol optionstype\nDEBUG:f90wrap.transform:marking public symbol kimdispersionequation\nDEBUG:f90wrap.transform:marking public symbol \nDEBUG:f90wrap.transform:marking public symbol kimdispersion_horton\nDEBUG:f90wrap.transform:marking public symbol initialize_kimdispersion_horton\nDEBUG:f90wrap.transform:visiting Module(name=kimdispersionequation_module)\nDEBUG:f90wrap.transform:visiting Type(name=optionstype)\nDEBUG:f90wrap.transform:visiting Type(name=kimdispersionequation)\nDEBUG:f90wrap.transform:visiting Module(name=kimdispersion_horton_module)\nDEBUG:f90wrap.transform:visiting Type(name=kimdispersion_horton)\nINFO:f90wrap.transform:adding missing constructor for optionstype\nINFO:f90wrap.transform:adding missing constructor for kimdispersionequation\nINFO:f90wrap.transform:adding missing constructor for kimdispersion_horton\nINFO:f90wrap.transform:adding missing destructor for optionstype\nINFO:f90wrap.transform:adding missing destructor for kimdispersionequation\nINFO:f90wrap.transform:adding missing destructor for kimdispersion_horton\nDEBUG:f90wrap.transform:visiting Module(name=kimdispersionequation_module)\nINFO:f90wrap.transform:visiting Module(name=kimdispersionequation_module) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=optionstype)\nINFO:f90wrap.transform:visiting Type(name=optionstype) found 1 constructors with names: ['optionstype_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=kimdispersionequation)\nINFO:f90wrap.transform:visiting Type(name=kimdispersionequation) found 1 constructors with names: ['kimdispersionequation_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=kimdispersion_horton_module)\nINFO:f90wrap.transform:visiting Module(name=kimdispersion_horton_module) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=kimdispersion_horton)\nINFO:f90wrap.transform:visiting Type(name=kimdispersion_horton) found 1 constructors with names: ['kimdispersion_horton_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in optionstype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in optionstype_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in kimdispersionequation_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in kimdispersionequation_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in kimdispersion_horton_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in kimdispersion_horton_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue254_getter_directmodule.c\nINFO:root:Generated Fortran support module: issue254_getter_direct_support.f90\nINFO:root:Generated minimal Python wrapper: issue254_getter_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['KIMDispersion_Horton.fpp', 'KIMDispersionEquation.fpp']",
        "Command: f90wrap -m issue254_getter_direct /tmp/tmpaf3jgcnz/KIMDispersion_Horton.fpp /tmp/tmpaf3jgcnz/KIMDispersionEquation.fpp  --direct-c -v",
        "Generated C files: ['_issue254_getter_directmodule.c']",
        "Preprocessed KIMDispersion_Horton.fpp -> KIMDispersion_Horton_processed.f90",
        "Preprocessed KIMDispersionEquation.fpp -> KIMDispersionEquation_processed.f90",
        "Found support module: issue254_getter_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c KIMDispersion_Horton_processed.f90 KIMDispersionEquation_processed.f90 issue254_getter_direct_support.f90",
        "Fortran compilation failed: /home/ert/code/f90wrap/examples/issue254_getter/KIMDispersion_Horton.f90:2:9:\n\n    2 |     use KIMDispersionEquation_module\n      |         1\nFatal Error: Cannot open module file \u2018kimdispersionequation_module.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\nissue254_getter_direct_support.f90:7:9:\n\n    7 |     use kimdispersion_horton_module\n      |         1\nFatal Error: Cannot open module file \u2018kimdispersion_horton_module.mod\u2019 for reading at (1): No such file or direct"
      ]
    },
    {
      "name": "issue258_derived_type_attributes",
      "path": "/home/ert/code/f90wrap/examples/issue258_derived_type_attributes",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp138rjusq/dta_ct.fpp', '/tmp/tmp138rjusq/dta_cc.fpp', '/tmp/tmp138rjusq/dta_tt.fpp', '/tmp/tmp138rjusq/dta_tc.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp138rjusq/dta_ct.fpp\nINFO:f90wrap.parser:parser reading type t_inner\nDEBUG:f90wrap.parser:    type t_inner\nINFO:f90wrap.parser:parser reading type t_outer\nDEBUG:f90wrap.parser:parser reading type t_outer bound procedures\nDEBUG:f90wrap.parser:found procedure binding print => t_outer_print\nDEBUG:f90wrap.parser:    type t_outer\nDEBUG:f90wrap.parser:    interface t_inner\nDEBUG:f90wrap.parser:    interface t_outer\nDEBUG:f90wrap.parser:    module function checking new_inner\nDEBUG:f90wrap.parser:        implicit type of \"new_inner\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_inner\nDEBUG:f90wrap.parser:    module function checking new_outer\nDEBUG:f90wrap.parser:        implicit type of \"new_outer\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_outer\nDEBUG:f90wrap.parser:    module subroutine checking t_outer_print\nDEBUG:f90wrap.parser:    module subroutine t_outer_print\nDEBUG:f90wrap.parser:    module function checking get_outer_inner\nDEBUG:f90wrap.parser:        implicit type of \"get_outer_inner\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function get_outer_inner\nDEBUG:f90wrap.parser:  module dta_ct\nDEBUG:f90wrap.parser:processing file /tmp/tmp138rjusq/dta_cc.fpp\nINFO:f90wrap.parser:parser reading type t_inner\nDEBUG:f90wrap.parser:parser reading type t_inner bound procedures\nDEBUG:f90wrap.parser:found procedure binding print => t_inner_print\nDEBUG:f90wrap.parser:    type t_inner\nINFO:f90wrap.parser:parser reading type t_outer\nDEBUG:f90wrap.parser:parser reading type t_outer bound procedures\nDEBUG:f90wrap.parser:found procedure binding print => t_outer_print\nDEBUG:f90wrap.parser:    type t_outer\nDEBUG:f90wrap.parser:    interface t_inner\nDEBUG:f90wrap.parser:    interface t_outer\nDEBUG:f90wrap.parser:    module function checking new_inner\nDEBUG:f90wrap.parser:        implicit type of \"new_inner\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_inner\nDEBUG:f90wrap.parser:    module function checking new_outer\nDEBUG:f90wrap.parser:        implicit type of \"new_outer\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_outer\nDEBUG:f90wrap.parser:    module subroutine checking t_inner_print\nDEBUG:f90wrap.parser:    module subroutine t_inner_print\nDEBUG:f90wrap.parser:    module subroutine checking t_outer_print\nDEBUG:f90wrap.parser:    module subroutine t_outer_print\nDEBUG:f90wrap.parser:    module function checking get_outer_inner\nDEBUG:f90wrap.parser:        implicit type of \"get_outer_inner\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function get_outer_inner\nDEBUG:f90wrap.parser:  module dta_cc\nDEBUG:f90wrap.parser:processing file /tmp/tmp138rjusq/dta_tt.fpp\nINFO:f90wrap.parser:parser reading type t_inner\nDEBUG:f90wrap.parser:    type t_inner\nINFO:f90wrap.parser:parser reading type t_outer\nDEBUG:f90wrap.parser:    type t_outer\nDEBUG:f90wrap.parser:    interface t_inner\nDEBUG:f90wrap.parser:    interface t_outer\nDEBUG:f90wrap.parser:    module function checking new_inner\nDEBUG:f90wrap.parser:        implicit type of \"new_inner\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_inner\nDEBUG:f90wrap.parser:    module function checking new_outer\nDEBUG:f90wrap.parser:        implicit type of \"new_outer\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_outer\nDEBUG:f90wrap.parser:    module function checking get_outer_inner\nDEBUG:f90wrap.parser:        implicit type of \"get_outer_inner\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function get_outer_inner\nDEBUG:f90wrap.parser:  module dta_tt\nDEBUG:f90wrap.parser:processing file /tmp/tmp138rjusq/dta_tc.fpp\nINFO:f90wrap.parser:parser reading type t_inner\nDEBUG:f90wrap.parser:parser reading type t_inner bound procedures\nDEBUG:f90wrap.parser:found procedure binding print => t_inner_print\nDEBUG:f90wrap.parser:    type t_inner\nINFO:f90wrap.parser:parser reading type t_outer\nDEBUG:f90wrap.parser:    type t_outer\nDEBUG:f90wrap.parser:    interface t_inner\nDEBUG:f90wrap.parser:    interface t_outer\nDEBUG:f90wrap.parser:    module function checking new_inner\nDEBUG:f90wrap.parser:        implicit type of \"new_inner\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_inner\nDEBUG:f90wrap.parser:    module function checking new_outer\nDEBUG:f90wrap.parser:        implicit type of \"new_outer\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function new_outer\nDEBUG:f90wrap.parser:    module subroutine checking t_inner_print\nDEBUG:f90wrap.parser:    module subroutine t_inner_print\nDEBUG:f90wrap.parser:    module function checking get_outer_inner\nDEBUG:f90wrap.parser:        implicit type of \"get_outer_inner\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function get_outer_inner\nDEBUG:f90wrap.parser:  module dta_tc\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_ct\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_ct\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_cc\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_cc\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_tt\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_tt\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_tc\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_tc\nDerived types detected in Fortran source files:\n{'class(t_inner)': Type(name=t_inner),\n 'class(t_outer)': Type(name=t_outer),\n 't_inner': Type(name=t_inner),\n 't_outer': Type(name=t_outer),\n 'type(t_inner)': Type(name=t_inner),\n 'type(t_outer)': Type(name=t_outer)}\n\nClass name mapping:\n{'class(t_inner)': 't_inner',\n 'class(t_outer)': 't_outer',\n 't_inner': 't_inner',\n 't_outer': 't_outer',\n 'type(t_inner)': 't_inner',\n 'type(t_outer)': 't_outer'}\nModules for each type:\n{'dta_tc': 'dta_tc'}\nDEBUG:f90wrap.transform:Creating method for t_outer from procedure t_outer_print.\nDEBUG:f90wrap.transform:Creating method for t_inner from procedure t_inner_print.\nDEBUG:f90wrap.transform:Creating method for t_outer from procedure t_outer_print.\nDEBUG:f90wrap.transform:Creating method for t_inner from procedure t_inner_print.\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_ct\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_ct\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_cc\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_cc\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_tt\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_tt\nDEBUG:f90wrap.fortran:type t_inner defined in module dta_tc\nDEBUG:f90wrap.fortran:type t_outer defined in module dta_tc\nDEBUG:f90wrap.transform:Move interface t_inner into type t_inner and mark constructor\nDEBUG:f90wrap.transform:Move interface t_outer into type t_outer and mark constructor\nDEBUG:f90wrap.transform:Move interface t_inner into type t_inner and mark constructor\nDEBUG:f90wrap.transform:Move interface t_outer into type t_outer and mark constructor\nDEBUG:f90wrap.transform:Move interface t_inner into type t_inner and mark constructor\nDEBUG:f90wrap.transform:Move interface t_outer into type t_outer and mark constructor\nDEBUG:f90wrap.transform:Move interface t_inner into type t_inner and mark constructor\nDEBUG:f90wrap.transform:Move interface t_outer into type t_outer and mark constructor\nDEBUG:f90wrap.transform:marking public symbol t_inner\nDEBUG:f90wrap.transform:marking public symbol new_inner\nDEBUG:f90wrap.transform:marking public symbol t_outer\nDEBUG:f90wrap.transform:marking public symbol new_outer\nDEBUG:f90wrap.transform:marking public symbol get_outer_inner\nDEBUG:f90wrap.transform:marking public symbol t_outer_print\nDEBUG:f90wrap.transform:marking public symbol t_inner\nDEBUG:f90wrap.transform:marking public symbol new_inner\nDEBUG:f90wrap.transform:marking public symbol t_outer\nDEBUG:f90wrap.transform:marking public symbol new_outer\nDEBUG:f90wrap.transform:marking public symbol t_outer_print\nDEBUG:f90wrap.transform:marking public symbol t_inner_print\nDEBUG:f90wrap.transform:marking public symbol get_outer_inner\nDEBUG:f90wrap.transform:marking public symbol t_inner\nDEBUG:f90wrap.transform:marking public symbol new_inner\nDEBUG:f90wrap.transform:marking public symbol t_outer\nDEBUG:f90wrap.transform:marking public symbol new_outer\nDEBUG:f90wrap.transform:marking public symbol get_outer_inner\nDEBUG:f90wrap.transform:marking public symbol t_inner\nDEBUG:f90wrap.transform:marking public symbol new_inner\nDEBUG:f90wrap.transform:marking public symbol t_outer\nDEBUG:f90wrap.transform:marking public symbol new_outer\nDEBUG:f90wrap.transform:marking public symbol get_outer_inner\nDEBUG:f90wrap.transform:marking public symbol t_inner_print\nINFO:f90wrap.transform:setting call_name of new_inner to t_inner\nINFO:f90wrap.transform:setting call_name of new_outer to t_outer\nINFO:f90wrap.transform:setting call_name of new_inner to t_inner\nINFO:f90wrap.transform:setting call_name of new_outer to t_outer\nINFO:f90wrap.transform:setting call_name of new_inner to t_inner\nINFO:f90wrap.transform:setting call_name of new_outer to t_outer\nINFO:f90wrap.transform:setting call_name of new_inner to t_inner\nINFO:f90wrap.transform:setting call_name of new_outer to t_outer\nDEBUG:f90wrap.transform:collapsing single-component interface new_inner\nDEBUG:f90wrap.transform:collapsing single-component interface new_outer\nDEBUG:f90wrap.transform:collapsing single-component interface new_inner\nDEBUG:f90wrap.transform:collapsing single-component interface new_outer\nDEBUG:f90wrap.transform:collapsing single-component interface new_inner\nDEBUG:f90wrap.transform:collapsing single-component interface new_outer\nDEBUG:f90wrap.transform:collapsing single-component interface new_inner\nDEBUG:f90wrap.transform:collapsing single-component interface new_outer\nDEBUG:f90wrap.transform:visiting Module(name=dta_ct)\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nDEBUG:f90wrap.transform:visiting Module(name=dta_cc)\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nDEBUG:f90wrap.transform:visiting Module(name=dta_tt)\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nDEBUG:f90wrap.transform:visiting Module(name=dta_tc)\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nINFO:f90wrap.transform:found constructor new_inner\nINFO:f90wrap.transform:found constructor new_outer\nINFO:f90wrap.transform:found constructor new_inner\nINFO:f90wrap.transform:found constructor new_outer\nINFO:f90wrap.transform:found constructor new_inner\nINFO:f90wrap.transform:found constructor new_outer\nINFO:f90wrap.transform:found constructor new_inner\nINFO:f90wrap.transform:found constructor new_outer\nINFO:f90wrap.transform:adding missing destructor for t_inner\nINFO:f90wrap.transform:adding missing destructor for t_outer\nINFO:f90wrap.transform:adding missing destructor for t_inner\nINFO:f90wrap.transform:adding missing destructor for t_outer\nINFO:f90wrap.transform:adding missing destructor for t_inner\nINFO:f90wrap.transform:adding missing destructor for t_outer\nINFO:f90wrap.transform:adding missing destructor for t_inner\nINFO:f90wrap.transform:adding missing destructor for t_outer\nDEBUG:f90wrap.transform:visiting Module(name=dta_ct)\nINFO:f90wrap.transform:visiting Module(name=dta_ct) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nINFO:f90wrap.transform:visiting Type(name=t_inner) found 1 constructors with names: ['new_inner']\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nINFO:f90wrap.transform:visiting Type(name=t_outer) found 1 constructors with names: ['new_outer']\nDEBUG:f90wrap.transform:visiting Module(name=dta_cc)\nINFO:f90wrap.transform:visiting Module(name=dta_cc) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nINFO:f90wrap.transform:visiting Type(name=t_inner) found 1 constructors with names: ['new_inner']\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nINFO:f90wrap.transform:visiting Type(name=t_outer) found 1 constructors with names: ['new_outer']\nDEBUG:f90wrap.transform:visiting Module(name=dta_tt)\nINFO:f90wrap.transform:visiting Module(name=dta_tt) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nINFO:f90wrap.transform:visiting Type(name=t_inner) found 1 constructors with names: ['new_inner']\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nINFO:f90wrap.transform:visiting Type(name=t_outer) found 1 constructors with names: ['new_outer']\nDEBUG:f90wrap.transform:visiting Module(name=dta_tc)\nINFO:f90wrap.transform:visiting Module(name=dta_tc) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_inner)\nINFO:f90wrap.transform:visiting Type(name=t_inner) found 1 constructors with names: ['new_inner']\nDEBUG:f90wrap.transform:visiting Type(name=t_outer)\nINFO:f90wrap.transform:visiting Type(name=t_outer) found 1 constructors with names: ['new_outer']\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in get_outer_inner\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in get_outer_inner\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in get_outer_inner\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in get_outer_inner\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in new_inner\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_inner_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_node\" in new_outer\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_outer_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in new_inner\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_inner_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_node\" in new_outer\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_outer_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in new_inner\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_inner_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_node\" in new_outer\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_outer_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_inner\" in new_inner\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_inner_finalise\nDEBUG:f90wrap.transform:allocating arg \"ret_node\" in new_outer\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_outer_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue258_derived_type_attributes_directmodule.c\nINFO:root:Generated Fortran support module: issue258_derived_type_attributes_direct_support.f90\nINFO:root:Generated minimal Python wrapper: issue258_derived_type_attributes_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['dta_ct.fpp', 'dta_cc.fpp', 'dta_tt.fpp', 'dta_tc.fpp']",
        "Command: f90wrap -m issue258_derived_type_attributes_direct /tmp/tmp138rjusq/dta_ct.fpp /tmp/tmp138rjusq/dta_cc.fpp /tmp/tmp138rjusq/dta_tt.fpp /tmp/tmp138rjusq/dta_tc.fpp  --direct-c -v",
        "Generated C files: ['_issue258_derived_type_attributes_directmodule.c']",
        "Preprocessed dta_ct.fpp -> dta_ct_processed.f90",
        "Preprocessed dta_cc.fpp -> dta_cc_processed.f90",
        "Preprocessed dta_tt.fpp -> dta_tt_processed.f90",
        "Preprocessed dta_tc.fpp -> dta_tc_processed.f90",
        "Found support module: issue258_derived_type_attributes_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c dta_ct_processed.f90 dta_cc_processed.f90 dta_tt_processed.f90 dta_tc_processed.f90 issue258_derived_type_attributes_direct_support.f90",
        "Fortran compilation failed: issue258_derived_type_attributes_direct_support.f90:17:22:\n\n   17 |         type(t_inner), pointer :: fptr\n      |                      1\nError: Type name \u2018t_inner\u2019 at (1) is ambiguous\nissue258_derived_type_attributes_direct_support.f90:19:18:\n\n   19 |         allocate(fptr)\n      |                  1~~~\nError: Allocate-object at (1) is neither a data pointer nor an allocatable variable\nissue258_derived_type_attributes_direct_support.f90:25:22:\n\n   25 |         type(t_inner), pointer :: fptr\n   "
      ]
    },
    {
      "name": "issue261_array_shapes",
      "path": "/home/ert/code/f90wrap/examples/issue261_array_shapes",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpe5qf8xwy/array_shapes.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpe5qf8xwy/array_shapes.fpp\nINFO:f90wrap.parser:parser reading type container\nDEBUG:f90wrap.parser:    type container\nDEBUG:f90wrap.parser:    module function checking one_array_dynamic\nDEBUG:f90wrap.parser:        implicit type of \"one_array_dynamic\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function one_array_dynamic\nDEBUG:f90wrap.parser:    module function checking one_array_fixed\nDEBUG:f90wrap.parser:        implicit type of \"one_array_fixed\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function one_array_fixed\nDEBUG:f90wrap.parser:    module function checking one_array_fixed_range\nDEBUG:f90wrap.parser:        implicit type of \"one_array_fixed_range\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function one_array_fixed_range\nDEBUG:f90wrap.parser:    module function checking one_array_explicit\nDEBUG:f90wrap.parser:        implicit type of \"one_array_explicit\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function one_array_explicit\nDEBUG:f90wrap.parser:    module function checking one_array_explicit_range\nDEBUG:f90wrap.parser:        implicit type of \"one_array_explicit_range\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function one_array_explicit_range\nDEBUG:f90wrap.parser:    module function checking two_arrays_dynamic\nDEBUG:f90wrap.parser:        implicit type of \"two_arrays_dynamic\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function two_arrays_dynamic\nDEBUG:f90wrap.parser:    module function checking two_arrays_fixed\nDEBUG:f90wrap.parser:        implicit type of \"two_arrays_fixed\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function two_arrays_fixed\nDEBUG:f90wrap.parser:    module function checking two_arrays_mixed\nDEBUG:f90wrap.parser:        implicit type of \"two_arrays_mixed\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function two_arrays_mixed\nDEBUG:f90wrap.parser:    module function checking two_arrays_2d_dynamic\nDEBUG:f90wrap.parser:        implicit type of \"two_arrays_2d_dynamic\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function two_arrays_2d_dynamic\nDEBUG:f90wrap.parser:    module function checking two_arrays_2d_fixed\nDEBUG:f90wrap.parser:        implicit type of \"two_arrays_2d_fixed\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function two_arrays_2d_fixed\nDEBUG:f90wrap.parser:    module function checking two_arrays_2d_fixed_whitespace\nDEBUG:f90wrap.parser:        implicit type of \"two_arrays_2d_fixed_whitespace\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function two_arrays_2d_fixed_whitespace\nDEBUG:f90wrap.parser:    module function checking two_arrays_2d_mixed\nDEBUG:f90wrap.parser:        implicit type of \"two_arrays_2d_mixed\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function two_arrays_2d_mixed\nDEBUG:f90wrap.parser:    module function checking get_container\nDEBUG:f90wrap.parser:        implicit type of \"get_container\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function get_container\nDEBUG:f90wrap.parser:    module function checking array_container_dynamic\nDEBUG:f90wrap.parser:        implicit type of \"array_container_dynamic\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function array_container_dynamic\nDEBUG:f90wrap.parser:    module function checking array_container_fixed\nDEBUG:f90wrap.parser:        implicit type of \"array_container_fixed\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function array_container_fixed\nDEBUG:f90wrap.parser:    module function checking array_container_dynamic_2d\nDEBUG:f90wrap.parser:        implicit type of \"array_container_dynamic_2d\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function array_container_dynamic_2d\nDEBUG:f90wrap.parser:  module array_shapes\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type container defined in module array_shapes\nDerived types detected in Fortran source files:\n{'class(container)': Type(name=container),\n 'container': Type(name=container),\n 'type(container)': Type(name=container)}\n\nClass name mapping:\n{'class(container)': 'container',\n 'container': 'container',\n 'type(container)': 'container'}\nModules for each type:\n{'array_shapes': 'array_shapes'}\nDEBUG:f90wrap.fortran:type container defined in module array_shapes\nDEBUG:f90wrap.transform:marking public symbol container\nDEBUG:f90wrap.transform:marking public symbol two_arrays_mixed\nDEBUG:f90wrap.transform:marking public symbol array_container_fixed\nDEBUG:f90wrap.transform:marking public symbol two_arrays_2d_dynamic\nDEBUG:f90wrap.transform:marking public symbol two_arrays_dynamic\nDEBUG:f90wrap.transform:marking public symbol one_array_fixed\nDEBUG:f90wrap.transform:marking public symbol two_arrays_2d_mixed\nDEBUG:f90wrap.transform:marking public symbol one_array_explicit_range\nDEBUG:f90wrap.transform:marking public symbol one_array_fixed_range\nDEBUG:f90wrap.transform:marking public symbol two_arrays_2d_fixed\nDEBUG:f90wrap.transform:marking public symbol array_container_dynamic_2d\nDEBUG:f90wrap.transform:marking public symbol one_array_dynamic\nDEBUG:f90wrap.transform:marking public symbol array_container_dynamic\nDEBUG:f90wrap.transform:marking public symbol one_array_explicit\nDEBUG:f90wrap.transform:marking public symbol two_arrays_fixed\nDEBUG:f90wrap.transform:marking public symbol two_arrays_2d_fixed_whitespace\nDEBUG:f90wrap.transform:marking public symbol get_container\nDEBUG:f90wrap.transform:visiting Module(name=array_shapes)\nDEBUG:f90wrap.transform:visiting Type(name=container)\nINFO:f90wrap.transform:adding missing constructor for container\nINFO:f90wrap.transform:adding missing destructor for container\nDEBUG:f90wrap.transform:visiting Module(name=array_shapes)\nINFO:f90wrap.transform:visiting Module(name=array_shapes) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=container)\nINFO:f90wrap.transform:visiting Type(name=container) found 1 constructors with names: ['container_initialise']\nDEBUG:f90wrap.transform:allocating arg \"ret_c\" in get_container\nDEBUG:f90wrap.transform:allocating arg \"this\" in container_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in container_finalise\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to two_arrays_mixed\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to two_arrays_mixed\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to array_container_fixed\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to two_arrays_2d_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to two_arrays_2d_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2), Argument(name=f90wrap_n3)] to two_arrays_2d_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to two_arrays_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to two_arrays_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2)] to two_arrays_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to two_arrays_2d_mixed\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to two_arrays_2d_mixed\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to one_array_explicit_range\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to one_array_explicit_range\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to array_container_dynamic_2d\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1), Argument(name=f90wrap_n2)] to array_container_dynamic_2d\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to one_array_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to one_array_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to array_container_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to array_container_dynamic\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to one_array_explicit\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to one_array_explicit\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to get_container\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue261_array_shapes_directmodule.c\nINFO:root:Generated Fortran support module: issue261_array_shapes_direct_support.f90\nINFO:root:Generated minimal Python wrapper: issue261_array_shapes_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['array_shapes.fpp']",
        "Command: f90wrap -m issue261_array_shapes_direct /tmp/tmpe5qf8xwy/array_shapes.fpp  --direct-c -v",
        "Generated C files: ['_issue261_array_shapes_directmodule.c']",
        "Preprocessed array_shapes.fpp -> array_shapes_processed.f90",
        "Found support module: issue261_array_shapes_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c array_shapes_processed.f90 issue261_array_shapes_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _issue261_array_shapes_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _issue261_array_shapes_directmodule.o",
        "Linking: gcc -shared _issue261_array_shapes_directmodule.o issue261_array_shapes_direct_support.o array_shapes_processed.o -lgfortran -o _issue261_array_shapes_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "issue32",
      "path": "/home/ert/code/f90wrap/examples/issue32",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'real': {'': 'float', '8': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpuclqyson/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpuclqyson/test.fpp\nDEBUG:f90wrap.parser:    module subroutine checking foo\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue32_directmodule.c\nINFO:root:Generated minimal Python wrapper: issue32_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m issue32_direct /tmp/tmpuclqyson/test.fpp -k /tmp/tmpuclqyson/kind_map --direct-c -v",
        "Generated C files: ['_issue32_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _issue32_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _issue32_directmodule.o",
        "Linking: gcc -shared _issue32_directmodule.o test_processed.o -lgfortran -o _issue32_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "issue41_abstract_classes",
      "path": "/home/ert/code/f90wrap/examples/issue41_abstract_classes",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpyeb4ephc/myclass_factory.fpp', '/tmp/tmpyeb4ephc/main.fpp', '/tmp/tmpyeb4ephc/myclass_impl.fpp', '/tmp/tmpyeb4ephc/myclass_base.fpp', '/tmp/tmpyeb4ephc/myclass_impl2.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpyeb4ephc/myclass_factory.fpp\nDEBUG:f90wrap.parser:    module function checking create_myclass\nDEBUG:f90wrap.parser:        implicit type of \"create_myclass\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function create_myclass\nDEBUG:f90wrap.parser:  module myclass_factory\nDEBUG:f90wrap.parser:processing file /tmp/tmpyeb4ephc/main.fpp\nDEBUG:f90wrap.parser:    module subroutine checking test\nDEBUG:f90wrap.parser:    program subroutine test\nDEBUG:f90wrap.parser:  program main\nDEBUG:f90wrap.parser:processing file /tmp/tmpyeb4ephc/myclass_impl.fpp\nINFO:f90wrap.parser:parser reading type myclass_impl_t\nDEBUG:f90wrap.parser:parser reading type myclass_impl_t bound procedures\nDEBUG:f90wrap.parser:found procedure binding get_value => get_value_impl\nDEBUG:f90wrap.parser:found final binding myclass_impl_destroy => myclass_impl_destroy\nDEBUG:f90wrap.parser:    type myclass_impl_t\nDEBUG:f90wrap.parser:    module subroutine checking get_value_impl\nDEBUG:f90wrap.parser:    module subroutine get_value_impl\nDEBUG:f90wrap.parser:    module subroutine checking myclass_impl_destroy\nDEBUG:f90wrap.parser:    module subroutine myclass_impl_destroy\nDEBUG:f90wrap.parser:  module myclass_impl\nDEBUG:f90wrap.parser:processing file /tmp/tmpyeb4ephc/myclass_base.fpp\nINFO:f90wrap.parser:parser reading type myclass_t\nDEBUG:f90wrap.parser:parser reading type myclass_t bound procedures\nDEBUG:f90wrap.parser:found deferred procedure(get_value_i) binding get_value\nDEBUG:f90wrap.parser:    type myclass_t\nDEBUG:f90wrap.parser:    module subroutine checking get_value_i\nDEBUG:f90wrap.parser:    abstract interface \nDEBUG:f90wrap.parser:  module myclass_base\nDEBUG:f90wrap.parser:processing file /tmp/tmpyeb4ephc/myclass_impl2.fpp\nINFO:f90wrap.parser:parser reading type myclass_impl2_t\nDEBUG:f90wrap.parser:parser reading type myclass_impl2_t bound procedures\nDEBUG:f90wrap.parser:found procedure binding get_value => get_value_impl2\nDEBUG:f90wrap.parser:found final binding myclass_impl2_destroy => myclass_impl2_destroy\nDEBUG:f90wrap.parser:    type myclass_impl2_t\nDEBUG:f90wrap.parser:    module subroutine checking get_value_impl2\nDEBUG:f90wrap.parser:    module subroutine get_value_impl2\nDEBUG:f90wrap.parser:    module subroutine checking myclass_impl2_destroy\nDEBUG:f90wrap.parser:    module subroutine myclass_impl2_destroy\nDEBUG:f90wrap.parser:  module myclass_impl2\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type myclass_impl_t defined in module myclass_impl\nDEBUG:f90wrap.fortran:type myclass_t defined in module myclass_base\nDEBUG:f90wrap.fortran:type myclass_impl2_t defined in module myclass_impl2\nDerived types detected in Fortran source files:\n{'class(myclass_impl2_t)': Type(name=myclass_impl2_t),\n 'class(myclass_impl_t)': Type(name=myclass_impl_t),\n 'class(myclass_t)': Type(name=myclass_t),\n 'myclass_impl2_t': Type(name=myclass_impl2_t),\n 'myclass_impl_t': Type(name=myclass_impl_t),\n 'myclass_t': Type(name=myclass_t),\n 'type(myclass_impl2_t)': Type(name=myclass_impl2_t),\n 'type(myclass_impl_t)': Type(name=myclass_impl_t),\n 'type(myclass_t)': Type(name=myclass_t)}\n\nClass name mapping:\n{'class(myclass_impl2_t)': 'myclass_impl2_t',\n 'class(myclass_impl_t)': 'myclass_impl_t',\n 'class(myclass_t)': 'myclass_t',\n 'myclass_impl2_t': 'myclass_impl2_t',\n 'myclass_impl_t': 'myclass_impl_t',\n 'myclass_t': 'myclass_t',\n 'type(myclass_impl2_t)': 'myclass_impl2_t',\n 'type(myclass_impl_t)': 'myclass_impl_t',\n 'type(myclass_t)': 'myclass_t'}\nModules for each type:\n{'myclass_base': 'myclass_base',\n 'myclass_impl': 'myclass_impl',\n 'myclass_impl2': 'myclass_impl2'}\nDEBUG:f90wrap.transform:Creating method for myclass_impl_t from procedure get_value_impl.\nDEBUG:f90wrap.transform:Creating method for myclass_impl_t from procedure myclass_impl_destroy.\nDEBUG:f90wrap.transform:Marking method myclass_impl_destroy__binding__myclass_impl_t as destructor for myclass_impl_t\nDEBUG:f90wrap.transform:Creating method for myclass_t from procedure get_value_i.\nDEBUG:f90wrap.transform:Creating method for myclass_impl2_t from procedure get_value_impl2.\nDEBUG:f90wrap.transform:Creating method for myclass_impl2_t from procedure myclass_impl2_destroy.\nDEBUG:f90wrap.transform:Marking method myclass_impl2_destroy__binding__myclass_impl2_t as destructor for myclass_impl2_t\nDEBUG:f90wrap.fortran:type myclass_impl_t defined in module myclass_impl\nDEBUG:f90wrap.fortran:type myclass_t defined in module myclass_base\nDEBUG:f90wrap.fortran:type myclass_impl2_t defined in module myclass_impl2\nDEBUG:f90wrap.transform:marking public symbol create_myclass\nDEBUG:f90wrap.transform:marking public symbol myclass_t\nDEBUG:f90wrap.transform:marking public symbol \nDEBUG:f90wrap.transform:marking public symbol myclass_impl_t\nDEBUG:f90wrap.transform:marking public symbol myclass_impl_destroy\nDEBUG:f90wrap.transform:marking public symbol get_value_impl\nDEBUG:f90wrap.transform:marking public symbol myclass_impl2_t\nDEBUG:f90wrap.transform:marking public symbol get_value_impl2\nDEBUG:f90wrap.transform:marking public symbol myclass_impl2_destroy\nDEBUG:f90wrap.transform:visiting Module(name=myclass_factory)\nDEBUG:f90wrap.transform:visiting Module(name=myclass_base)\nDEBUG:f90wrap.transform:visiting Type(name=myclass_t)\nDEBUG:f90wrap.transform:visiting Module(name=myclass_impl)\nDEBUG:f90wrap.transform:visiting Type(name=myclass_impl_t)\nDEBUG:f90wrap.transform:visiting Module(name=myclass_impl2)\nDEBUG:f90wrap.transform:visiting Type(name=myclass_impl2_t)\nINFO:f90wrap.transform:adding missing constructor for myclass_t\nINFO:f90wrap.transform:adding missing constructor for myclass_impl_t\nINFO:f90wrap.transform:adding missing constructor for myclass_impl2_t\nINFO:f90wrap.transform:adding missing destructor for myclass_t\nINFO:f90wrap.transform:found destructor myclass_impl_destroy\nINFO:f90wrap.transform:found destructor myclass_impl2_destroy\nDEBUG:f90wrap.transform:visiting Module(name=myclass_factory)\nINFO:f90wrap.transform:visiting Module(name=myclass_factory) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Module(name=myclass_base)\nINFO:f90wrap.transform:visiting Module(name=myclass_base) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=myclass_t)\nINFO:f90wrap.transform:visiting Type(name=myclass_t) found 1 constructors with names: ['myclass_t_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=myclass_impl)\nINFO:f90wrap.transform:visiting Module(name=myclass_impl) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=myclass_impl_t)\nINFO:f90wrap.transform:visiting Type(name=myclass_impl_t) found 1 constructors with names: ['myclass_impl_t_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=myclass_impl2)\nINFO:f90wrap.transform:visiting Module(name=myclass_impl2) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=myclass_impl2_t)\nINFO:f90wrap.transform:visiting Type(name=myclass_impl2_t) found 1 constructors with names: ['myclass_impl2_t_initialise']\nDEBUG:f90wrap.transform:allocating arg \"ret_myobject\" in create_myclass\nDEBUG:f90wrap.transform:allocating arg \"this\" in myclass_t_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in myclass_t_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in myclass_impl_t_initialise\nDEBUG:f90wrap.transform:allocating arg \"this\" in myclass_impl2_t_initialise\nDEBUG:f90wrap.transform:deallocating arg \"self\" in myclass_impl_destroy__binding__myclass_impl_t\nDEBUG:f90wrap.transform:deallocating arg \"self\" in myclass_impl2_destroy__binding__myclass_impl2_t\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _issue41_abstract_classes_directmodule.c\nINFO:root:Generated Fortran support module: issue41_abstract_classes_direct_support.f90\nINFO:root:Generated minimal Python wrapper: issue41_abstract_classes_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['myclass_factory.fpp', 'main.fpp', 'myclass_impl.fpp', 'myclass_base.fpp', 'myclass_impl2.fpp']",
        "Command: f90wrap -m issue41_abstract_classes_direct /tmp/tmpyeb4ephc/myclass_factory.fpp /tmp/tmpyeb4ephc/main.fpp /tmp/tmpyeb4ephc/myclass_impl.fpp /tmp/tmpyeb4ephc/myclass_base.fpp /tmp/tmpyeb4ephc/myclass_impl2.fpp  --direct-c -v",
        "Generated C files: ['_issue41_abstract_classes_directmodule.c']",
        "Preprocessed myclass_factory.fpp -> myclass_factory_processed.f90",
        "Preprocessed main.fpp -> main_processed.f90",
        "Preprocessed myclass_impl.fpp -> myclass_impl_processed.f90",
        "Preprocessed myclass_base.fpp -> myclass_base_processed.f90",
        "Preprocessed myclass_impl2.fpp -> myclass_impl2_processed.f90",
        "Found support module: issue41_abstract_classes_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c myclass_factory_processed.f90 main_processed.f90 myclass_impl_processed.f90 myclass_base_processed.f90 myclass_impl2_processed.f90 issue41_abstract_classes_direct_support.f90",
        "Fortran compilation failed: /home/ert/code/f90wrap/examples/issue41_abstract_classes/myclass_factory.f90:3:5:\n\n    3 | use myclass_base, only: myclass_t\n      |     1\nFatal Error: Cannot open module file \u2018myclass_base.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\n/home/ert/code/f90wrap/examples/issue41_abstract_classes/main.f90:2:9:\n\n    2 |     use myclass_factory, only: create_myclass\n      |         1\nFatal Error: Cannot open module file \u2018myclass_factory.mod\u2019 for reading at (1): No such file"
      ]
    },
    {
      "name": "keyword_renaming_issue160",
      "path": "/home/ert/code/f90wrap/examples/keyword_renaming_issue160",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'integer': {'': 'long_long', '4': 'int', '8': 'long_long', 'dp': 'long_long'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpuxmjx_wc/rename.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpuxmjx_wc/rename.fpp\nINFO:f90wrap.parser:parser reading type class2\nDEBUG:f90wrap.parser:    type class2\nDEBUG:f90wrap.parser:    module subroutine checking is\nDEBUG:f90wrap.parser:    module subroutine is\nDEBUG:f90wrap.parser:  module global\nDEBUG:f90wrap.parser:    module function checking in\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type class2 defined in module global\nDerived types detected in Fortran source files:\n{'class(class2)': Type(name=class2),\n 'class2': Type(name=class2),\n 'type(class2)': Type(name=class2)}\n\nClass name mapping:\n{'class(class2)': 'class2', 'class2': 'class2', 'type(class2)': 'class2'}\nModules for each type:\n{'global': 'global'}\nDEBUG:f90wrap.fortran:type class2 defined in module global\nDEBUG:f90wrap.transform:marking public symbol class2\nDEBUG:f90wrap.transform:marking public symbol abc\nDEBUG:f90wrap.transform:marking public symbol lambda\nDEBUG:f90wrap.transform:marking public symbol with\nDEBUG:f90wrap.transform:marking public symbol is\nDEBUG:f90wrap.transform:visiting Module(name=global)\nDEBUG:f90wrap.transform:visiting Type(name=class2)\nINFO:f90wrap.transform:adding missing constructor for class2\nINFO:f90wrap.transform:adding missing destructor for class2\nDEBUG:f90wrap.transform:visiting Module(name=global)\nINFO:f90wrap.transform:visiting Module(name=global) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=class2)\nINFO:f90wrap.transform:visiting Type(name=class2) found 1 constructors with names: ['class2_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in class2_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in class2_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _keyword_renaming_issue160_directmodule.c\nINFO:root:Generated Fortran support module: keyword_renaming_issue160_direct_support.f90\nINFO:root:Generated minimal Python wrapper: keyword_renaming_issue160_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['rename.fpp']",
        "Command: f90wrap -m keyword_renaming_issue160_direct /tmp/tmpuxmjx_wc/rename.fpp -k /tmp/tmpuxmjx_wc/kind_map --direct-c -v",
        "Generated C files: ['_keyword_renaming_issue160_directmodule.c']",
        "Preprocessed rename.fpp -> rename_processed.f90",
        "Found support module: keyword_renaming_issue160_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c rename_processed.f90 keyword_renaming_issue160_direct_support.f90",
        "Fortran compilation failed: keyword_renaming_issue160_direct_support.f90:6:9:\n\n    6 |     use global_\n      |         1\nFatal Error: Cannot open module file \u2018global_.mod\u2019 for reading at (1): No such file or directory\ncompilation terminated.\n"
      ]
    },
    {
      "name": "kind_map_default",
      "path": "/home/ert/code/f90wrap/examples/kind_map_default",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpwy1mb6k8/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpwy1mb6k8/main.fpp\nDEBUG:f90wrap.parser:  program main\nINFO:f90wrap.parser:marking module m_test as default public\nDEBUG:f90wrap.parser:    module function checking test_real\nDEBUG:f90wrap.parser:        implicit type of \"test_real\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function test_real\nDEBUG:f90wrap.parser:    module function checking test_real4\nDEBUG:f90wrap.parser:        implicit type of \"test_real4\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function test_real4\nDEBUG:f90wrap.parser:    module function checking test_real8\nDEBUG:f90wrap.parser:        implicit type of \"test_real8\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function test_real8\nDEBUG:f90wrap.parser:  module m_test\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking public symbol test_real\nDEBUG:f90wrap.transform:marking public symbol test_real8\nDEBUG:f90wrap.transform:marking public symbol test_real4\nDEBUG:f90wrap.transform:visiting Module(name=m_test)\nDEBUG:f90wrap.transform:visiting Module(name=m_test)\nINFO:f90wrap.transform:visiting Module(name=m_test) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _kind_map_default_directmodule.c\nINFO:root:Generated minimal Python wrapper: kind_map_default_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m kind_map_default_direct /tmp/tmpwy1mb6k8/main.fpp  --direct-c -v",
        "Generated C files: ['_kind_map_default_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _kind_map_default_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _kind_map_default_directmodule.o",
        "Linking: gcc -shared _kind_map_default_directmodule.o main_processed.o -lgfortran -o _kind_map_default_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "long_subroutine_name",
      "path": "/home/ert/code/f90wrap/examples/long_subroutine_name",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp2871sm4l/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp2871sm4l/main.fpp\nINFO:f90wrap.parser:parser reading type m_long_subroutine_name_type\nDEBUG:f90wrap.parser:    type m_long_subroutine_name_type\nINFO:f90wrap.parser:parser reading type m_long_subroutine_name_type_2\nDEBUG:f90wrap.parser:    type m_long_subroutine_name_type_2\nDEBUG:f90wrap.parser:    module subroutine checking m_long_subroutine_name_subroutine\nDEBUG:f90wrap.parser:    module subroutine m_long_subroutine_name_subroutine\nDEBUG:f90wrap.parser:  module m_long_subroutine_name\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type m_long_subroutine_name_type defined in module m_long_subroutine_name\nDEBUG:f90wrap.fortran:type m_long_subroutine_name_type_2 defined in module m_long_subroutine_name\nDerived types detected in Fortran source files:\n{'class(m_long_subroutine_name_type)': Type(name=m_long_subroutine_name_type),\n 'class(m_long_subroutine_name_type_2)': Type(name=m_long_subroutine_name_type_2),\n 'm_long_subroutine_name_type': Type(name=m_long_subroutine_name_type),\n 'm_long_subroutine_name_type_2': Type(name=m_long_subroutine_name_type_2),\n 'type(m_long_subroutine_name_type)': Type(name=m_long_subroutine_name_type),\n 'type(m_long_subroutine_name_type_2)': Type(name=m_long_subroutine_name_type_2)}\n\nClass name mapping:\n{'class(m_long_subroutine_name_type)': 'm_long_subroutine_name_type',\n 'class(m_long_subroutine_name_type_2)': 'm_long_subroutine_name_type_2',\n 'm_long_subroutine_name_type': 'm_long_subroutine_name_type',\n 'm_long_subroutine_name_type_2': 'm_long_subroutine_name_type_2',\n 'type(m_long_subroutine_name_type)': 'm_long_subroutine_name_type',\n 'type(m_long_subroutine_name_type_2)': 'm_long_subroutine_name_type_2'}\nModules for each type:\n{'m_long_subroutine_name': 'm_long_subroutine_name'}\nDEBUG:f90wrap.fortran:type m_long_subroutine_name_type defined in module m_long_subroutine_name\nDEBUG:f90wrap.fortran:type m_long_subroutine_name_type_2 defined in module m_long_subroutine_name\nDEBUG:f90wrap.transform:marking public symbol m_long_subroutine_name_type\nDEBUG:f90wrap.transform:marking public symbol m_long_subroutine_name_type_2\nDEBUG:f90wrap.transform:marking public symbol m_long_subroutine_name_integer\nDEBUG:f90wrap.transform:marking public symbol m_long_subroutine_name_subroutine\nDEBUG:f90wrap.transform:visiting Module(name=m_long_subroutine_name)\nDEBUG:f90wrap.transform:visiting Type(name=m_long_subroutine_name_type)\nDEBUG:f90wrap.transform:visiting Type(name=m_long_subroutine_name_type_2)\nINFO:f90wrap.transform:adding missing constructor for m_long_subroutine_name_type\nINFO:f90wrap.transform:adding missing constructor for m_long_subroutine_name_type_2\nINFO:f90wrap.transform:adding missing destructor for m_long_subroutine_name_type\nINFO:f90wrap.transform:adding missing destructor for m_long_subroutine_name_type_2\nDEBUG:f90wrap.transform:visiting Module(name=m_long_subroutine_name)\nINFO:f90wrap.transform:visiting Module(name=m_long_subroutine_name) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=m_long_subroutine_name_type)\nINFO:f90wrap.transform:visiting Type(name=m_long_subroutine_name_type) found 1 constructors with names: ['m_long_subroutine_name_type_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=m_long_subroutine_name_type_2)\nINFO:f90wrap.transform:visiting Type(name=m_long_subroutine_name_type_2) found 1 constructors with names: ['m_long_subroutine_name_type_2_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in m_long_subroutine_name_type_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in m_long_subroutine_name_type_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in m_long_subroutine_name_type_2_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in m_long_subroutine_name_type_2_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _long_subroutine_name_directmodule.c\nINFO:root:Generated Fortran support module: long_subroutine_name_direct_support.f90\nINFO:root:Generated minimal Python wrapper: long_subroutine_name_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m long_subroutine_name_direct /tmp/tmp2871sm4l/main.fpp  --direct-c -v",
        "Generated C files: ['_long_subroutine_name_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Found support module: long_subroutine_name_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90 long_subroutine_name_direct_support.f90",
        "Fortran compilation failed: long_subroutine_name_direct_support.f90:49:80:\n\n   49 |     subroutine f90wrap_m_long_subroutine_name_type__get__m_long_subroutine_name_type_integer(self_ptr, value) bind(C, name='__m_long_subroutine_name_MOD_f90wrap_m_long_subroutine_name_type__get__m_long_subroutine_name_type_integer')\n      |                                                                                1\nError: Name at (1) is too long\nlong_subroutine_name_direct_support.f90:50:38:\n\n   50 |         type(c_ptr), value :: self_"
      ]
    },
    {
      "name": "mockderivetype",
      "path": "/home/ert/code/f90wrap/examples/mockderivetype",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'complex': {'': 'complex_float',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp3kxjteqa/leveltwomod.fpp', '/tmp/tmp3kxjteqa/define.fpp', '/tmp/tmp3kxjteqa/fwrap.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp3kxjteqa/leveltwomod.fpp\nINFO:f90wrap.parser:parser reading type leveltwo\nDEBUG:f90wrap.parser:    type leveltwo\nDEBUG:f90wrap.parser:  module leveltwomod\nDEBUG:f90wrap.parser:processing file /tmp/tmp3kxjteqa/define.fpp\nINFO:f90wrap.parser:parser reading type atype\nDEBUG:f90wrap.parser:    type atype\nINFO:f90wrap.parser:parser reading type unused_type\nDEBUG:f90wrap.parser:    type unused_type\nDEBUG:f90wrap.parser:    module subroutine checking use_set_vars\nDEBUG:f90wrap.parser:    module subroutine use_set_vars\nDEBUG:f90wrap.parser:    module function checking return_a_type_func\nDEBUG:f90wrap.parser:        implicit type of \"return_a_type_func\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_a_type_func\nDEBUG:f90wrap.parser:    module subroutine checking return_a_type_sub\nDEBUG:f90wrap.parser:    module subroutine return_a_type_sub\nDEBUG:f90wrap.parser:  module define_a_type\nDEBUG:f90wrap.parser:    module subroutine checking top_level\nINFO:f90wrap.parser:parser reading type horrible_type\nDEBUG:f90wrap.parser:    type horrible_type\nDEBUG:f90wrap.parser:  module horrible\nDEBUG:f90wrap.parser:processing file /tmp/tmp3kxjteqa/fwrap.fpp\nDEBUG:f90wrap.parser:    module subroutine checking do_stuff\nDEBUG:f90wrap.parser:    module subroutine do_stuff\nDEBUG:f90wrap.parser:    module subroutine checking not_used\nDEBUG:f90wrap.parser:    module subroutine not_used\nDEBUG:f90wrap.parser:  module use_a_type\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type leveltwo defined in module leveltwomod\nDEBUG:f90wrap.fortran:type atype defined in module define_a_type\nDEBUG:f90wrap.fortran:type unused_type defined in module define_a_type\nDEBUG:f90wrap.fortran:type horrible_type defined in module horrible\nDerived types detected in Fortran source files:\n{'atype': Type(name=atype),\n 'class(atype)': Type(name=atype),\n 'class(horrible_type)': Type(name=horrible_type),\n 'class(leveltwo)': Type(name=leveltwo),\n 'class(unused_type)': Type(name=unused_type),\n 'horrible_type': Type(name=horrible_type),\n 'leveltwo': Type(name=leveltwo),\n 'type(atype)': Type(name=atype),\n 'type(horrible_type)': Type(name=horrible_type),\n 'type(leveltwo)': Type(name=leveltwo),\n 'type(unused_type)': Type(name=unused_type),\n 'unused_type': Type(name=unused_type)}\n\nClass name mapping:\n{'atype': 'atype',\n 'class(atype)': 'atype',\n 'class(horrible_type)': 'horrible_type',\n 'class(leveltwo)': 'leveltwo',\n 'class(unused_type)': 'unused_type',\n 'horrible_type': 'horrible_type',\n 'leveltwo': 'leveltwo',\n 'type(atype)': 'atype',\n 'type(horrible_type)': 'horrible_type',\n 'type(leveltwo)': 'leveltwo',\n 'type(unused_type)': 'unused_type',\n 'unused_type': 'unused_type'}\nModules for each type:\n{'define_a_type': 'define_a_type',\n 'horrible': 'horrible',\n 'leveltwomod': 'leveltwomod'}\nDEBUG:f90wrap.fortran:type leveltwo defined in module leveltwomod\nDEBUG:f90wrap.fortran:type atype defined in module define_a_type\nDEBUG:f90wrap.fortran:type unused_type defined in module define_a_type\nDEBUG:f90wrap.fortran:type horrible_type defined in module horrible\nDEBUG:f90wrap.transform:marking public symbol leveltwo\nDEBUG:f90wrap.transform:marking public symbol atype\nDEBUG:f90wrap.transform:marking public symbol unused_type\nDEBUG:f90wrap.transform:marking public symbol a_set_real\nDEBUG:f90wrap.transform:marking public symbol a_set_bool\nDEBUG:f90wrap.transform:marking public symbol return_a_type_sub\nDEBUG:f90wrap.transform:marking public symbol use_set_vars\nDEBUG:f90wrap.transform:marking public symbol return_a_type_func\nDEBUG:f90wrap.transform:marking public symbol horrible_type\nDEBUG:f90wrap.transform:marking public symbol a_real\nDEBUG:f90wrap.transform:marking public symbol p\nDEBUG:f90wrap.transform:marking public symbol p_array\nDEBUG:f90wrap.transform:marking public symbol vector\nDEBUG:f90wrap.transform:marking public symbol do_stuff\nDEBUG:f90wrap.transform:marking public symbol not_used\nDEBUG:f90wrap.transform:visiting Module(name=leveltwomod)\nDEBUG:f90wrap.transform:visiting Type(name=leveltwo)\nDEBUG:f90wrap.transform:visiting Module(name=define_a_type)\nDEBUG:f90wrap.transform:visiting Type(name=atype)\nDEBUG:f90wrap.transform:visiting Type(name=unused_type)\nDEBUG:f90wrap.transform:visiting Module(name=horrible)\nDEBUG:f90wrap.transform:visiting Type(name=horrible_type)\nDEBUG:f90wrap.transform:visiting Module(name=use_a_type)\nINFO:f90wrap.transform:adding missing constructor for leveltwo\nINFO:f90wrap.transform:adding missing constructor for atype\nINFO:f90wrap.transform:adding missing constructor for unused_type\nINFO:f90wrap.transform:adding missing constructor for horrible_type\nINFO:f90wrap.transform:adding missing destructor for leveltwo\nINFO:f90wrap.transform:adding missing destructor for atype\nINFO:f90wrap.transform:adding missing destructor for unused_type\nINFO:f90wrap.transform:adding missing destructor for horrible_type\nDEBUG:f90wrap.transform:visiting Module(name=leveltwomod)\nINFO:f90wrap.transform:visiting Module(name=leveltwomod) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=leveltwo)\nINFO:f90wrap.transform:visiting Type(name=leveltwo) found 1 constructors with names: ['leveltwo_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=define_a_type)\nINFO:f90wrap.transform:visiting Module(name=define_a_type) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=atype)\nINFO:f90wrap.transform:visiting Type(name=atype) found 1 constructors with names: ['atype_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=unused_type)\nINFO:f90wrap.transform:visiting Type(name=unused_type) found 1 constructors with names: ['unused_type_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=horrible)\nINFO:f90wrap.transform:visiting Module(name=horrible) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=horrible_type)\nINFO:f90wrap.transform:visiting Type(name=horrible_type) found 1 constructors with names: ['horrible_type_initialise']\nDEBUG:f90wrap.transform:visiting Module(name=use_a_type)\nINFO:f90wrap.transform:visiting Module(name=use_a_type) found 0 constructors with names: []\nDEBUG:f90wrap.transform:allocating arg \"a\" in return_a_type_sub\nDEBUG:f90wrap.transform:allocating arg \"ret_a\" in return_a_type_func\nDEBUG:f90wrap.transform:allocating arg \"this\" in leveltwo_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in leveltwo_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in atype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in atype_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in unused_type_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in unused_type_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in horrible_type_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in horrible_type_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _mockderivetype_directmodule.c\nINFO:root:Generated Fortran support module: mockderivetype_direct_support.f90\nINFO:root:Generated minimal Python wrapper: mockderivetype_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['leveltwomod.fpp', 'define.fpp', 'fwrap.fpp']",
        "Command: f90wrap -m mockderivetype_direct /tmp/tmp3kxjteqa/leveltwomod.fpp /tmp/tmp3kxjteqa/define.fpp /tmp/tmp3kxjteqa/fwrap.fpp -k /tmp/tmp3kxjteqa/kind_map --direct-c -v",
        "Generated C files: ['_mockderivetype_directmodule.c']",
        "Preprocessed leveltwomod.fpp -> leveltwomod_processed.f90",
        "Preprocessed define.fpp -> define_processed.f90",
        "Preprocessed fwrap.fpp -> fwrap_processed.f90",
        "Found support module: mockderivetype_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c leveltwomod_processed.f90 define_processed.f90 fwrap_processed.f90 mockderivetype_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _mockderivetype_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _mockderivetype_directmodule.o",
        "Linking: gcc -shared _mockderivetype_directmodule.o mockderivetype_direct_support.o fwrap_processed.o define_processed.o leveltwomod_processed.o -lgfortran -o _mockderivetype_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "mod_arg_clash",
      "path": "/home/ert/code/f90wrap/examples/mod_arg_clash",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpdedyt5u4/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpdedyt5u4/test.fpp\nINFO:f90wrap.parser:marking module cell as default private\nINFO:f90wrap.parser:parser reading type unit_cell\nDEBUG:f90wrap.parser:    type unit_cell\nDEBUG:f90wrap.parser:    module subroutine checking cell_dosomething\nDEBUG:f90wrap.parser:    module subroutine cell_dosomething\nDEBUG:f90wrap.parser:  module cell\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type unit_cell defined in module cell\nDerived types detected in Fortran source files:\n{'class(unit_cell)': Type(name=unit_cell),\n 'type(unit_cell)': Type(name=unit_cell),\n 'unit_cell': Type(name=unit_cell)}\n\nClass name mapping:\n{'class(unit_cell)': 'unit_cell',\n 'type(unit_cell)': 'unit_cell',\n 'unit_cell': 'unit_cell'}\nModules for each type:\n{'cell': 'cell'}\nDEBUG:f90wrap.fortran:type unit_cell defined in module cell\nDEBUG:f90wrap.transform:marking public symbol unit_cell\nDEBUG:f90wrap.transform:visiting Module(name=cell)\nDEBUG:f90wrap.transform:visiting Type(name=unit_cell)\nINFO:f90wrap.transform:adding missing constructor for unit_cell\nINFO:f90wrap.transform:adding missing destructor for unit_cell\nDEBUG:f90wrap.transform:visiting Module(name=cell)\nINFO:f90wrap.transform:visiting Module(name=cell) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=unit_cell)\nINFO:f90wrap.transform:visiting Type(name=unit_cell) found 1 constructors with names: ['unit_cell_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in unit_cell_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in unit_cell_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _mod_arg_clash_directmodule.c\nINFO:root:Generated Fortran support module: mod_arg_clash_direct_support.f90\nINFO:root:Generated minimal Python wrapper: mod_arg_clash_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m mod_arg_clash_direct /tmp/tmpdedyt5u4/test.fpp  --direct-c -v",
        "Generated C files: ['_mod_arg_clash_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Found support module: mod_arg_clash_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90 mod_arg_clash_direct_support.f90",
        "Fortran compilation failed: mod_arg_clash_direct_support.f90:67:65:\n\n   67 |     subroutine f90wrap_unit_cell__get__species_symbol(self_ptr, value) bind(C, name='__cell_MOD_f90wrap_unit_cell__get__species_symbol')\n      |                                                                 1~~~~\nError: Character dummy argument \u2018value\u2019 at (1) must be of constant length of one or assumed length, unless it has assumed shape or assumed rank, as procedure \u2018f90wrap_unit_cell__get__species_symbol\u2019 has the BIND(C) attribute\nmod_arg_cla"
      ]
    },
    {
      "name": "optional_args_issue53",
      "path": "/home/ert/code/f90wrap/examples/optional_args_issue53",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp8ajp95ui/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp8ajp95ui/main.fpp\nDEBUG:f90wrap.parser:    module subroutine checking wrap\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _optional_args_issue53_directmodule.c\nINFO:root:Generated minimal Python wrapper: optional_args_issue53_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m optional_args_issue53_direct /tmp/tmp8ajp95ui/main.fpp  --direct-c -v",
        "Generated C files: ['_optional_args_issue53_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _optional_args_issue53_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _optional_args_issue53_directmodule.o",
        "Linking: gcc -shared _optional_args_issue53_directmodule.o main_processed.o -lgfortran -o _optional_args_issue53_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "optional_derived_arrays",
      "path": "/home/ert/code/f90wrap/examples/optional_derived_arrays",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp58lbn_rf/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp58lbn_rf/test.fpp\nINFO:f90wrap.parser:marking module io as default private\nINFO:f90wrap.parser:parser reading type keyword\nDEBUG:f90wrap.parser:    type keyword\nDEBUG:f90wrap.parser:    module subroutine checking io_freeform_open\nDEBUG:f90wrap.parser:    module subroutine io_freeform_open\nDEBUG:f90wrap.parser:  module io\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type keyword defined in module io\nDerived types detected in Fortran source files:\n{'class(keyword)': Type(name=keyword),\n 'keyword': Type(name=keyword),\n 'type(keyword)': Type(name=keyword)}\n\nClass name mapping:\n{'class(keyword)': 'keyword', 'keyword': 'keyword', 'type(keyword)': 'keyword'}\nModules for each type:\n{'io': 'io'}\nDEBUG:f90wrap.fortran:type keyword defined in module io\nDEBUG:f90wrap.transform:marking public symbol keyword\nWARNING:f90wrap.transform:test removing optional argument keywords as only one dimensional fixed-length arrays are currently supported for derived type type(keyword) array\nDEBUG:f90wrap.transform:visiting Module(name=io)\nDEBUG:f90wrap.transform:visiting Type(name=keyword)\nINFO:f90wrap.transform:adding missing constructor for keyword\nINFO:f90wrap.transform:adding missing destructor for keyword\nDEBUG:f90wrap.transform:visiting Module(name=io)\nINFO:f90wrap.transform:visiting Module(name=io) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=keyword)\nINFO:f90wrap.transform:visiting Type(name=keyword) found 1 constructors with names: ['keyword_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in keyword_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in keyword_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _optional_derived_arrays_directmodule.c\nINFO:root:Generated Fortran support module: optional_derived_arrays_direct_support.f90\nINFO:root:Generated minimal Python wrapper: optional_derived_arrays_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m optional_derived_arrays_direct /tmp/tmp58lbn_rf/test.fpp  --direct-c -v",
        "Generated C files: ['_optional_derived_arrays_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Found support module: optional_derived_arrays_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90 optional_derived_arrays_direct_support.f90",
        "Fortran compilation failed: optional_derived_arrays_direct_support.f90:85:60:\n\n   85 |     subroutine f90wrap_keyword__get__description(self_ptr, value) bind(C, name='__io_MOD_f90wrap_keyword__get__description')\n      |                                                            1~~~~\nError: Character dummy argument \u2018value\u2019 at (1) must be of constant length of one or assumed length, unless it has assumed shape or assumed rank, as procedure \u2018f90wrap_keyword__get__description\u2019 has the BIND(C) attribute\noptional_derived_arrays"
      ]
    },
    {
      "name": "optional_string",
      "path": "/home/ert/code/f90wrap/examples/optional_string",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp3fe22p_9/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp3fe22p_9/main.fpp\nINFO:f90wrap.parser:marking module m_string_test as default private\nDEBUG:f90wrap.parser:    module subroutine checking string_in\nDEBUG:f90wrap.parser:    module subroutine string_in\nDEBUG:f90wrap.parser:    module subroutine checking string_in_array\nDEBUG:f90wrap.parser:    module subroutine string_in_array\nDEBUG:f90wrap.parser:    module subroutine checking string_in_array_hardcoded_size\nDEBUG:f90wrap.parser:    module subroutine string_in_array_hardcoded_size\nDEBUG:f90wrap.parser:    module subroutine checking string_to_string\nDEBUG:f90wrap.parser:    module subroutine string_to_string\nDEBUG:f90wrap.parser:    module subroutine checking string_to_string_array\nDEBUG:f90wrap.parser:    module subroutine string_to_string_array\nDEBUG:f90wrap.parser:    module subroutine checking string_out\nDEBUG:f90wrap.parser:    module subroutine string_out\nDEBUG:f90wrap.parser:    module subroutine checking string_out_optional\nDEBUG:f90wrap.parser:    module subroutine string_out_optional\nDEBUG:f90wrap.parser:    module subroutine checking string_out_optional_array\nDEBUG:f90wrap.parser:    module subroutine string_out_optional_array\nDEBUG:f90wrap.parser:  module m_string_test\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:visiting Module(name=m_string_test)\nDEBUG:f90wrap.transform:visiting Module(name=m_string_test)\nINFO:f90wrap.transform:visiting Module(name=m_string_test) found 0 constructors with names: []\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to string_out_optional_array\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to string_in_array\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to string_to_string_array\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to string_to_string_array\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _optional_string_directmodule.c\nINFO:root:Generated minimal Python wrapper: optional_string_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "c_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m optional_string_direct /tmp/tmp3fe22p_9/main.fpp  --direct-c -v",
        "Generated C files: ['_optional_string_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _optional_string_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _optional_string_directmodule.o",
        "Failed to compile _optional_string_directmodule.c: _optional_string_directmodule.c: In function \u2018wrap_string_out_optional_array\u2019:\n_optional_string_directmodule.c:75:69: error: \u2018output_data\u2019 undeclared (first use in this function)\n   75 |     __m_string_test_MOD_string_out_optional_array((output_present ? output_data : NULL));\n      |                                                                     ^~~~~~~~~~~\n_optional_string_directmodule.c:75:69: note: each undeclared identifier is reported only once for each function it appears in\n"
      ]
    },
    {
      "name": "output_kind",
      "path": "/home/ert/code/f90wrap/examples/output_kind",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpe0qd25uh/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpe0qd25uh/main.fpp\nINFO:f90wrap.parser:marking module m_out_test as default private\nDEBUG:f90wrap.parser:    module function checking out_scalar_int1\nDEBUG:f90wrap.parser:        implicit type of \"out_scalar_int1\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_scalar_int1\nDEBUG:f90wrap.parser:    module function checking out_scalar_int2\nDEBUG:f90wrap.parser:        implicit type of \"out_scalar_int2\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_scalar_int2\nDEBUG:f90wrap.parser:    module function checking out_scalar_int4\nDEBUG:f90wrap.parser:        implicit type of \"out_scalar_int4\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_scalar_int4\nDEBUG:f90wrap.parser:    module function checking out_scalar_int8\nDEBUG:f90wrap.parser:        implicit type of \"out_scalar_int8\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_scalar_int8\nDEBUG:f90wrap.parser:    module function checking out_scalar_real4\nDEBUG:f90wrap.parser:        implicit type of \"out_scalar_real4\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_scalar_real4\nDEBUG:f90wrap.parser:    module function checking out_scalar_real8\nDEBUG:f90wrap.parser:        implicit type of \"out_scalar_real8\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_scalar_real8\nDEBUG:f90wrap.parser:    module function checking out_array_int4\nDEBUG:f90wrap.parser:        implicit type of \"out_array_int4\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_array_int4\nDEBUG:f90wrap.parser:    module function checking out_array_int8\nDEBUG:f90wrap.parser:        implicit type of \"out_array_int8\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_array_int8\nDEBUG:f90wrap.parser:    module function checking out_array_real4\nDEBUG:f90wrap.parser:        implicit type of \"out_array_real4\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_array_real4\nDEBUG:f90wrap.parser:    module function checking out_array_real8\nDEBUG:f90wrap.parser:        implicit type of \"out_array_real8\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function out_array_real8\nDEBUG:f90wrap.parser:  module m_out_test\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:visiting Module(name=m_out_test)\nDEBUG:f90wrap.transform:visiting Module(name=m_out_test)\nINFO:f90wrap.transform:visiting Module(name=m_out_test) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _output_kind_directmodule.c\nINFO:root:Generated minimal Python wrapper: output_kind_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m output_kind_direct /tmp/tmpe0qd25uh/main.fpp  --direct-c -v",
        "Generated C files: ['_output_kind_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _output_kind_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _output_kind_directmodule.o",
        "Linking: gcc -shared _output_kind_directmodule.o main_processed.o -lgfortran -o _output_kind_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "passbyreference",
      "path": "/home/ert/code/f90wrap/examples/passbyreference",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpoyvor07y/mycode.F90'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpoyvor07y/mycode.F90\nINFO:f90wrap.parser:parser reading type mytype\nDEBUG:f90wrap.parser:    type mytype\nDEBUG:f90wrap.parser:    module subroutine checking mysubroutine\nDEBUG:f90wrap.parser:    module subroutine mysubroutine\nDEBUG:f90wrap.parser:  module mymodule\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type mytype defined in module mymodule\nDerived types detected in Fortran source files:\n{'class(mytype)': Type(name=mytype),\n 'mytype': Type(name=mytype),\n 'type(mytype)': Type(name=mytype)}\n\nClass name mapping:\n{'class(mytype)': 'mytype', 'mytype': 'mytype', 'type(mytype)': 'mytype'}\nModules for each type:\n{'mymodule': 'mymodule'}\nDEBUG:f90wrap.fortran:type mytype defined in module mymodule\nDEBUG:f90wrap.transform:marking public symbol mytype\nDEBUG:f90wrap.transform:marking public symbol mysubroutine\nDEBUG:f90wrap.transform:visiting Module(name=mymodule)\nDEBUG:f90wrap.transform:visiting Type(name=mytype)\nINFO:f90wrap.transform:adding missing constructor for mytype\nINFO:f90wrap.transform:adding missing destructor for mytype\nDEBUG:f90wrap.transform:visiting Module(name=mymodule)\nINFO:f90wrap.transform:visiting Module(name=mymodule) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=mytype)\nINFO:f90wrap.transform:visiting Type(name=mytype) found 1 constructors with names: ['mytype_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in mytype_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in mytype_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _passbyreference_directmodule.c\nINFO:root:Generated Fortran support module: passbyreference_direct_support.f90\nINFO:root:Generated minimal Python wrapper: passbyreference_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using source files for f90wrap: ['mycode.F90']",
        "Command: f90wrap -m passbyreference_direct /tmp/tmpoyvor07y/mycode.F90  --direct-c -v",
        "Generated C files: ['_passbyreference_directmodule.c']",
        "Preprocessed mycode.F90 -> mycode_processed.f90",
        "Found support module: passbyreference_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c mycode_processed.f90 passbyreference_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _passbyreference_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _passbyreference_directmodule.o",
        "Linking: gcc -shared _passbyreference_directmodule.o passbyreference_direct_support.o mycode_processed.o -lgfortran -o _passbyreference_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "recursive_type",
      "path": "/home/ert/code/f90wrap/examples/recursive_type",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp8omy9qbr/tree.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp8omy9qbr/tree.fpp\nINFO:f90wrap.parser:parser reading type node\nDEBUG:f90wrap.parser:    type node\nDEBUG:f90wrap.parser:    module subroutine checking treeAllocate\nDEBUG:f90wrap.parser:    module subroutine treeAllocate\nDEBUG:f90wrap.parser:    module subroutine checking treedeallocate\nDEBUG:f90wrap.parser:    module subroutine treedeallocate\nDEBUG:f90wrap.parser:  module tree\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type node defined in module tree\nDerived types detected in Fortran source files:\n{'class(node)': Type(name=node),\n 'node': Type(name=node),\n 'type(node)': Type(name=node)}\n\nClass name mapping:\n{'class(node)': 'node', 'node': 'node', 'type(node)': 'node'}\nModules for each type:\n{'tree': 'tree'}\nDEBUG:f90wrap.fortran:type node defined in module tree\nDEBUG:f90wrap.transform:marking public symbol node\nDEBUG:f90wrap.transform:marking public symbol treeallocate\nDEBUG:f90wrap.transform:marking public symbol treedeallocate\nINFO:f90wrap.transform:added method treeallocate to type node\nINFO:f90wrap.transform:added method treedeallocate to type node\nDEBUG:f90wrap.transform:visiting Module(name=tree)\nDEBUG:f90wrap.transform:visiting Type(name=node)\nINFO:f90wrap.transform:found constructor treeallocate\nINFO:f90wrap.transform:found destructor treedeallocate\nDEBUG:f90wrap.transform:visiting Module(name=tree)\nINFO:f90wrap.transform:visiting Module(name=tree) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=node)\nINFO:f90wrap.transform:visiting Type(name=node) found 1 constructors with names: ['treeallocate']\nDEBUG:f90wrap.transform:allocating arg \"root\" in treeallocate\nDEBUG:f90wrap.transform:deallocating arg \"root\" in treedeallocate\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _recursive_type_directmodule.c\nINFO:root:Generated Fortran support module: recursive_type_direct_support.f90\nINFO:root:Generated minimal Python wrapper: recursive_type_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['tree.fpp']",
        "Command: f90wrap -m recursive_type_direct /tmp/tmp8omy9qbr/tree.fpp -k /tmp/tmp8omy9qbr/kind_map --direct-c -v",
        "Generated C files: ['_recursive_type_directmodule.c']",
        "Preprocessed tree.fpp -> tree_processed.f90",
        "Found support module: recursive_type_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c tree_processed.f90 recursive_type_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _recursive_type_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _recursive_type_directmodule.o",
        "Linking: gcc -shared _recursive_type_directmodule.o recursive_type_direct_support.o tree_processed.o -lgfortran -o _recursive_type_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "recursive_type_array",
      "path": "/home/ert/code/f90wrap/examples/recursive_type_array",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'character': {'': 'char'},\n 'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float', '8': 'double', 'dp': 'double', 'idp': 'double'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp6lz3s0uq/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp6lz3s0uq/test.fpp\nINFO:f90wrap.parser:parser reading type t_node\nDEBUG:f90wrap.parser:    type t_node\nDEBUG:f90wrap.parser:    module subroutine checking allocate_node\nDEBUG:f90wrap.parser:    module subroutine allocate_node\nDEBUG:f90wrap.parser:    module subroutine checking deallocate_node\nDEBUG:f90wrap.parser:    module subroutine deallocate_node\nDEBUG:f90wrap.parser:  module mod_recursive_type_array\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type t_node defined in module mod_recursive_type_array\nDerived types detected in Fortran source files:\n{'class(t_node)': Type(name=t_node),\n 't_node': Type(name=t_node),\n 'type(t_node)': Type(name=t_node)}\n\nClass name mapping:\n{'class(t_node)': 't_node', 't_node': 't_node', 'type(t_node)': 't_node'}\nModules for each type:\n{'mod_recursive_type_array': 'mod_recursive_type_array'}\nDEBUG:f90wrap.fortran:type t_node defined in module mod_recursive_type_array\nDEBUG:f90wrap.transform:marking public symbol t_node\nDEBUG:f90wrap.transform:marking public symbol allocate_node\nDEBUG:f90wrap.transform:marking public symbol deallocate_node\nDEBUG:f90wrap.transform:visiting Module(name=mod_recursive_type_array)\nDEBUG:f90wrap.transform:visiting Type(name=t_node)\nINFO:f90wrap.transform:adding missing constructor for t_node\nINFO:f90wrap.transform:adding missing destructor for t_node\nDEBUG:f90wrap.transform:visiting Module(name=mod_recursive_type_array)\nINFO:f90wrap.transform:visiting Module(name=mod_recursive_type_array) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_node)\nINFO:f90wrap.transform:visiting Type(name=t_node) found 1 constructors with names: ['t_node_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_node_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_node_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _recursive_type_array_directmodule.c\nINFO:root:Generated Fortran support module: recursive_type_array_direct_support.f90\nINFO:root:Generated minimal Python wrapper: recursive_type_array_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m recursive_type_array_direct /tmp/tmp6lz3s0uq/test.fpp -k /tmp/tmp6lz3s0uq/kind_map --direct-c -v",
        "Generated C files: ['_recursive_type_array_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Found support module: recursive_type_array_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90 recursive_type_array_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _recursive_type_array_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _recursive_type_array_directmodule.o",
        "Linking: gcc -shared _recursive_type_array_directmodule.o recursive_type_array_direct_support.o test_processed.o -lgfortran -o _recursive_type_array_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "remove_pointer_arg",
      "path": "/home/ert/code/f90wrap/examples/remove_pointer_arg",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmprdab61xg/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmprdab61xg/main.fpp\nDEBUG:f90wrap.parser:  program main\nINFO:f90wrap.parser:marking module m_test as default public\nDEBUG:f90wrap.parser:    module function checking to_be_ignored_1\nDEBUG:f90wrap.parser:        implicit type of \"to_be_ignored_1\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function to_be_ignored_1\nDEBUG:f90wrap.parser:    module function checking to_be_ignored_2\nDEBUG:f90wrap.parser:        implicit type of \"to_be_ignored_2\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function to_be_ignored_2\nDEBUG:f90wrap.parser:    module function checking not_to_be_ignored\nDEBUG:f90wrap.parser:        implicit type of \"not_to_be_ignored\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function not_to_be_ignored\nDEBUG:f90wrap.parser:  module m_test\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking public symbol not_to_be_ignored\nDEBUG:f90wrap.transform:marking public symbol to_be_ignored_2\nDEBUG:f90wrap.transform:marking public symbol to_be_ignored_1\nWARNING:f90wrap.transform:removing routine to_be_ignored_2 due to pointer arguments\nWARNING:f90wrap.transform:removing routine to_be_ignored_1 due to pointer arguments\nDEBUG:f90wrap.transform:visiting Module(name=m_test)\nDEBUG:f90wrap.transform:visiting Module(name=m_test)\nINFO:f90wrap.transform:visiting Module(name=m_test) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _remove_pointer_arg_directmodule.c\nINFO:root:Generated minimal Python wrapper: remove_pointer_arg_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m remove_pointer_arg_direct /tmp/tmprdab61xg/main.fpp  --direct-c -v",
        "Generated C files: ['_remove_pointer_arg_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _remove_pointer_arg_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _remove_pointer_arg_directmodule.o",
        "Linking: gcc -shared _remove_pointer_arg_directmodule.o main_processed.o -lgfortran -o _remove_pointer_arg_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "return_array",
      "path": "/home/ert/code/f90wrap/examples/return_array",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpysaac8qj/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpysaac8qj/main.fpp\nINFO:f90wrap.parser:marking module m_test as default private\nINFO:f90wrap.parser:parser reading type t_array_wrapper\nDEBUG:f90wrap.parser:    type t_array_wrapper\nINFO:f90wrap.parser:parser reading type t_array_2d_wrapper\nDEBUG:f90wrap.parser:    type t_array_2d_wrapper\nINFO:f90wrap.parser:parser reading type t_array_double_wrapper\nDEBUG:f90wrap.parser:    type t_array_double_wrapper\nINFO:f90wrap.parser:parser reading type t_value\nDEBUG:f90wrap.parser:    type t_value\nINFO:f90wrap.parser:parser reading type t_size_2d\nDEBUG:f90wrap.parser:    type t_size_2d\nDEBUG:f90wrap.parser:    module subroutine checking array_init\nDEBUG:f90wrap.parser:    module subroutine array_init\nDEBUG:f90wrap.parser:    module subroutine checking array_2d_init\nDEBUG:f90wrap.parser:    module subroutine array_2d_init\nDEBUG:f90wrap.parser:    module subroutine checking array_wrapper_init\nDEBUG:f90wrap.parser:    module subroutine array_wrapper_init\nDEBUG:f90wrap.parser:    module subroutine checking array_free\nDEBUG:f90wrap.parser:    module subroutine array_free\nDEBUG:f90wrap.parser:    module function checking return_scalar\nDEBUG:f90wrap.parser:        implicit type of \"return_scalar\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_scalar\nDEBUG:f90wrap.parser:    module function checking return_hard_coded_1d\nDEBUG:f90wrap.parser:        implicit type of \"return_hard_coded_1d\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_hard_coded_1d\nDEBUG:f90wrap.parser:    module function checking return_hard_coded_2d\nDEBUG:f90wrap.parser:        implicit type of \"return_hard_coded_2d\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_hard_coded_2d\nDEBUG:f90wrap.parser:    module function checking return_array_member\nDEBUG:f90wrap.parser:        implicit type of \"return_array_member\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_member\nDEBUG:f90wrap.parser:    module function checking return_array_member_2d\nDEBUG:f90wrap.parser:        implicit type of \"return_array_member_2d\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_member_2d\nDEBUG:f90wrap.parser:    module function checking return_array_member_wrapper\nDEBUG:f90wrap.parser:        implicit type of \"return_array_member_wrapper\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_member_wrapper\nDEBUG:f90wrap.parser:    module function checking return_array_input\nDEBUG:f90wrap.parser:        implicit type of \"return_array_input\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_input\nDEBUG:f90wrap.parser:    module function checking return_array_input_2d\nDEBUG:f90wrap.parser:        implicit type of \"return_array_input_2d\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_input_2d\nDEBUG:f90wrap.parser:    module function checking return_array_size\nDEBUG:f90wrap.parser:        implicit type of \"return_array_size\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_size\nDEBUG:f90wrap.parser:    module function checking return_array_size_2d_in\nDEBUG:f90wrap.parser:        implicit type of \"return_array_size_2d_in\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_size_2d_in\nDEBUG:f90wrap.parser:    module function checking return_array_size_2d_out\nDEBUG:f90wrap.parser:        implicit type of \"return_array_size_2d_out\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_array_size_2d_out\nDEBUG:f90wrap.parser:    module function checking return_derived_type_value\nDEBUG:f90wrap.parser:        implicit type of \"return_derived_type_value\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function return_derived_type_value\nDEBUG:f90wrap.parser:  module m_test\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type t_array_wrapper defined in module m_test\nDEBUG:f90wrap.fortran:type t_array_2d_wrapper defined in module m_test\nDEBUG:f90wrap.fortran:type t_array_double_wrapper defined in module m_test\nDEBUG:f90wrap.fortran:type t_value defined in module m_test\nDEBUG:f90wrap.fortran:type t_size_2d defined in module m_test\nDerived types detected in Fortran source files:\n{'class(t_array_2d_wrapper)': Type(name=t_array_2d_wrapper),\n 'class(t_array_double_wrapper)': Type(name=t_array_double_wrapper),\n 'class(t_array_wrapper)': Type(name=t_array_wrapper),\n 'class(t_size_2d)': Type(name=t_size_2d),\n 'class(t_value)': Type(name=t_value),\n 't_array_2d_wrapper': Type(name=t_array_2d_wrapper),\n 't_array_double_wrapper': Type(name=t_array_double_wrapper),\n 't_array_wrapper': Type(name=t_array_wrapper),\n 't_size_2d': Type(name=t_size_2d),\n 't_value': Type(name=t_value),\n 'type(t_array_2d_wrapper)': Type(name=t_array_2d_wrapper),\n 'type(t_array_double_wrapper)': Type(name=t_array_double_wrapper),\n 'type(t_array_wrapper)': Type(name=t_array_wrapper),\n 'type(t_size_2d)': Type(name=t_size_2d),\n 'type(t_value)': Type(name=t_value)}\n\nClass name mapping:\n{'class(t_array_2d_wrapper)': 't_array_2d_wrapper',\n 'class(t_array_double_wrapper)': 't_array_double_wrapper',\n 'class(t_array_wrapper)': 't_array_wrapper',\n 'class(t_size_2d)': 't_size_2d',\n 'class(t_value)': 't_value',\n 't_array_2d_wrapper': 't_array_2d_wrapper',\n 't_array_double_wrapper': 't_array_double_wrapper',\n 't_array_wrapper': 't_array_wrapper',\n 't_size_2d': 't_size_2d',\n 't_value': 't_value',\n 'type(t_array_2d_wrapper)': 't_array_2d_wrapper',\n 'type(t_array_double_wrapper)': 't_array_double_wrapper',\n 'type(t_array_wrapper)': 't_array_wrapper',\n 'type(t_size_2d)': 't_size_2d',\n 'type(t_value)': 't_value'}\nModules for each type:\n{'m_test': 'm_test'}\nDEBUG:f90wrap.fortran:type t_array_wrapper defined in module m_test\nDEBUG:f90wrap.fortran:type t_array_2d_wrapper defined in module m_test\nDEBUG:f90wrap.fortran:type t_array_double_wrapper defined in module m_test\nDEBUG:f90wrap.fortran:type t_value defined in module m_test\nDEBUG:f90wrap.fortran:type t_size_2d defined in module m_test\nDEBUG:f90wrap.transform:marking public symbol t_array_wrapper\nDEBUG:f90wrap.transform:marking public symbol t_array_2d_wrapper\nDEBUG:f90wrap.transform:marking public symbol t_array_double_wrapper\nDEBUG:f90wrap.transform:marking public symbol t_value\nDEBUG:f90wrap.transform:marking public symbol t_size_2d\nDEBUG:f90wrap.transform:visiting Module(name=m_test)\nDEBUG:f90wrap.transform:visiting Type(name=t_array_wrapper)\nDEBUG:f90wrap.transform:visiting Type(name=t_array_2d_wrapper)\nDEBUG:f90wrap.transform:visiting Type(name=t_array_double_wrapper)\nDEBUG:f90wrap.transform:visiting Type(name=t_value)\nDEBUG:f90wrap.transform:visiting Type(name=t_size_2d)\nINFO:f90wrap.transform:adding missing constructor for t_array_wrapper\nINFO:f90wrap.transform:adding missing constructor for t_array_2d_wrapper\nINFO:f90wrap.transform:adding missing constructor for t_array_double_wrapper\nINFO:f90wrap.transform:adding missing constructor for t_value\nINFO:f90wrap.transform:adding missing constructor for t_size_2d\nINFO:f90wrap.transform:adding missing destructor for t_array_wrapper\nINFO:f90wrap.transform:adding missing destructor for t_array_2d_wrapper\nINFO:f90wrap.transform:adding missing destructor for t_array_double_wrapper\nINFO:f90wrap.transform:adding missing destructor for t_value\nINFO:f90wrap.transform:adding missing destructor for t_size_2d\nDEBUG:f90wrap.transform:visiting Module(name=m_test)\nINFO:f90wrap.transform:visiting Module(name=m_test) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_array_wrapper)\nINFO:f90wrap.transform:visiting Type(name=t_array_wrapper) found 1 constructors with names: ['t_array_wrapper_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=t_array_2d_wrapper)\nINFO:f90wrap.transform:visiting Type(name=t_array_2d_wrapper) found 1 constructors with names: ['t_array_2d_wrapper_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=t_array_double_wrapper)\nINFO:f90wrap.transform:visiting Type(name=t_array_double_wrapper) found 1 constructors with names: ['t_array_double_wrapper_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=t_value)\nINFO:f90wrap.transform:visiting Type(name=t_value) found 1 constructors with names: ['t_value_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=t_size_2d)\nINFO:f90wrap.transform:visiting Type(name=t_size_2d) found 1 constructors with names: ['t_size_2d_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_array_wrapper_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_array_wrapper_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_array_2d_wrapper_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_array_2d_wrapper_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_array_double_wrapper_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_array_double_wrapper_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_value_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_value_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_size_2d_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_size_2d_finalise\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to return_array_size\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n1)] to return_array_size\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to return_array_member_wrapper\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to return_array_size_2d_in\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2)] to return_array_size_2d_in\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to return_array_member_2d\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to return_array_input\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to return_derived_type_value\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to return_array_member\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to return_array_size_2d_out\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n2), Argument(name=f90wrap_n3)] to return_array_size_2d_out\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n4), Argument(name=f90wrap_n5)] to return_array_size_2d_out\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to return_array_input_2d\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _return_array_directmodule.c\nINFO:root:Generated Fortran support module: return_array_direct_support.f90\nINFO:root:Generated minimal Python wrapper: return_array_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m return_array_direct /tmp/tmpysaac8qj/main.fpp  --direct-c -v",
        "Generated C files: ['_return_array_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Found support module: return_array_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90 return_array_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _return_array_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _return_array_directmodule.o",
        "Linking: gcc -shared _return_array_directmodule.o return_array_direct_support.o main_processed.o -lgfortran -o _return_array_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "string_array_input_f2py",
      "path": "/home/ert/code/f90wrap/examples/string_array_input_f2py",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpsktuln65/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpsktuln65/main.fpp\nDEBUG:f90wrap.parser:    module subroutine checking string_in_array\nDEBUG:f90wrap.parser:        implicit type of \"input\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module subroutine checking string_in_array_optional\nDEBUG:f90wrap.parser:        implicit type of \"input\" inferred from its name as \"integer\"\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _string_array_input_f2py_directmodule.c\nINFO:root:Generated minimal Python wrapper: string_array_input_f2py_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m string_array_input_f2py_direct /tmp/tmpsktuln65/main.fpp  --direct-c -v",
        "Generated C files: ['_string_array_input_f2py_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _string_array_input_f2py_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _string_array_input_f2py_directmodule.o",
        "Linking: gcc -shared _string_array_input_f2py_directmodule.o main_processed.o -lgfortran -o _string_array_input_f2py_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "strings",
      "path": "/home/ert/code/f90wrap/examples/strings",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dp': 'double',\n          'idp': 'double',\n          'isp': 'float'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpyscjbisi/string_io.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpyscjbisi/string_io.fpp\nDEBUG:f90wrap.parser:    module function checking func_generate_string\nDEBUG:f90wrap.parser:        implicit type of \"func_generate_string\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function func_generate_string\nDEBUG:f90wrap.parser:    module function checking func_return_string\nDEBUG:f90wrap.parser:        implicit type of \"func_return_string\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function func_return_string\nDEBUG:f90wrap.parser:    module subroutine checking generate_string\nDEBUG:f90wrap.parser:    module subroutine generate_string\nDEBUG:f90wrap.parser:    module subroutine checking return_string\nDEBUG:f90wrap.parser:    module subroutine return_string\nDEBUG:f90wrap.parser:    module subroutine checking set_global_string\nDEBUG:f90wrap.parser:    module subroutine set_global_string\nDEBUG:f90wrap.parser:    module subroutine checking inout_string\nDEBUG:f90wrap.parser:    module subroutine inout_string\nDEBUG:f90wrap.parser:  module string_io\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking public symbol global_string\nDEBUG:f90wrap.transform:marking public symbol set_global_string\nDEBUG:f90wrap.transform:marking public symbol return_string\nDEBUG:f90wrap.transform:marking public symbol func_return_string\nDEBUG:f90wrap.transform:marking public symbol func_generate_string\nDEBUG:f90wrap.transform:marking public symbol generate_string\nDEBUG:f90wrap.transform:marking public symbol inout_string\nDEBUG:f90wrap.transform:visiting Module(name=string_io)\nDEBUG:f90wrap.transform:visiting Module(name=string_io)\nINFO:f90wrap.transform:visiting Module(name=string_io) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _strings_directmodule.c\nINFO:root:Generated minimal Python wrapper: strings_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['string_io.fpp']",
        "Command: f90wrap -m strings_direct /tmp/tmpyscjbisi/string_io.fpp -k /tmp/tmpyscjbisi/kind_map --direct-c -v",
        "Generated C files: ['_strings_directmodule.c']",
        "Preprocessed string_io.fpp -> string_io_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c string_io_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _strings_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _strings_directmodule.o",
        "Linking: gcc -shared _strings_directmodule.o string_io_processed.o -lgfortran -o _strings_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "subroutine_args",
      "path": "/home/ert/code/f90wrap/examples/subroutine_args",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{'complex': {'': 'complex_float',\n             '16': 'complex_long_double',\n             '8': 'complex_double',\n             'dp': 'complex_double'},\n 'integer': {'4': 'int', '8': 'long_long', 'dp': 'long_long'},\n 'real': {'': 'float',\n          '4': 'float',\n          '8': 'double',\n          'dp': 'double',\n          'idp': 'double',\n          'isp': 'float'}}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpi4ywt8m0/subroutine_mod.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpi4ywt8m0/subroutine_mod.fpp\nDEBUG:f90wrap.parser:    module subroutine checking routine_with_simple_args\nDEBUG:f90wrap.parser:    module subroutine routine_with_simple_args\nDEBUG:f90wrap.parser:    module subroutine checking routine_with_multiline_args\nDEBUG:f90wrap.parser:    module subroutine routine_with_multiline_args\nDEBUG:f90wrap.parser:    module subroutine checking routine_with_commented_args\nDEBUG:f90wrap.parser:    module subroutine routine_with_commented_args\nDEBUG:f90wrap.parser:    module subroutine checking routine_with_more_commented_args\nDEBUG:f90wrap.parser:    module subroutine routine_with_more_commented_args\nDEBUG:f90wrap.parser:  module subroutine_mod\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nDEBUG:f90wrap.transform:marking public symbol routine_with_multiline_args\nDEBUG:f90wrap.transform:marking public symbol routine_with_commented_args\nDEBUG:f90wrap.transform:marking public symbol routine_with_more_commented_args\nDEBUG:f90wrap.transform:marking public symbol routine_with_simple_args\nDEBUG:f90wrap.transform:visiting Module(name=subroutine_mod)\nDEBUG:f90wrap.transform:visiting Module(name=subroutine_mod)\nINFO:f90wrap.transform:visiting Module(name=subroutine_mod) found 0 constructors with names: []\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _subroutine_args_directmodule.c\nINFO:root:Generated minimal Python wrapper: subroutine_args_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['subroutine_mod.fpp']",
        "Command: f90wrap -m subroutine_args_direct /tmp/tmpi4ywt8m0/subroutine_mod.fpp -k /tmp/tmpi4ywt8m0/kind_map --direct-c -v",
        "Generated C files: ['_subroutine_args_directmodule.c']",
        "Preprocessed subroutine_mod.fpp -> subroutine_mod_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c subroutine_mod_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _subroutine_args_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _subroutine_args_directmodule.o",
        "Linking: gcc -shared _subroutine_args_directmodule.o subroutine_mod_processed.o -lgfortran -o _subroutine_args_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "subroutine_contains_issue101",
      "path": "/home/ert/code/f90wrap/examples/subroutine_contains_issue101",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp6mrhldac/test.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp6mrhldac/test.fpp\nDEBUG:f90wrap.parser:    module subroutine checking routine_member_procedures\nDEBUG:f90wrap.parser:    module subroutine checking member_procedure\nDEBUG:f90wrap.parser:    module function checking member_function\nDEBUG:f90wrap.parser:        implicit type of \"member_function\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module subroutine checking routine_member_procedures2\nDEBUG:f90wrap.parser:    module subroutine checking member_procedure\nDEBUG:f90wrap.parser:    module subroutine checking member_procedure2\nDEBUG:f90wrap.parser:    module subroutine checking member_procedure3\nDEBUG:f90wrap.parser:    module function checking member_function\nDEBUG:f90wrap.parser:        implicit type of \"member_function\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function checking member_function2\nDEBUG:f90wrap.parser:        implicit type of \"member_function2\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function checking member_function3\nDEBUG:f90wrap.parser:        implicit type of \"member_function3\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function checking function_member_procedures\nDEBUG:f90wrap.parser:        implicit type of \"function_member_procedures\" inferred from its name as \"real\"\nDEBUG:f90wrap.parser:    module function checking member_function\nDEBUG:f90wrap.parser:        implicit type of \"member_function\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function checking member_function2\nDEBUG:f90wrap.parser:        implicit type of \"member_function2\" inferred from its name as \"integer\"\ndone parsing source.\n\nDerived types detected in Fortran source files:\n{}\n\nClass name mapping:\n{}\nModules for each type:\n{}\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _subroutine_contains_issue101_directmodule.c\nINFO:root:Generated minimal Python wrapper: subroutine_contains_issue101_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['test.fpp']",
        "Command: f90wrap -m subroutine_contains_issue101_direct /tmp/tmp6mrhldac/test.fpp  --direct-c -v",
        "Generated C files: ['_subroutine_contains_issue101_directmodule.c']",
        "Preprocessed test.fpp -> test_processed.f90",
        "Compiling Fortran: gfortran -fPIC -c test_processed.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _subroutine_contains_issue101_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _subroutine_contains_issue101_directmodule.o",
        "Linking: gcc -shared _subroutine_contains_issue101_directmodule.o test_processed.o -lgfortran -o _subroutine_contains_issue101_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    },
    {
      "name": "type_bn",
      "path": "/home/ert/code/f90wrap/examples/type_bn",
      "status": "FAIL",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmpwx_3665e/type_bn.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmpwx_3665e/type_bn.fpp\nINFO:f90wrap.parser:parser reading type type_face\nDEBUG:f90wrap.parser:    type type_face\nDEBUG:f90wrap.parser:  module module_structure\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type type_face defined in module module_structure\nDerived types detected in Fortran source files:\n{'class(type_face)': Type(name=type_face),\n 'type(type_face)': Type(name=type_face),\n 'type_face': Type(name=type_face)}\n\nClass name mapping:\n{'class(type_face)': 'type_face',\n 'type(type_face)': 'type_face',\n 'type_face': 'type_face'}\nModules for each type:\n{'module_structure': 'module_structure'}\nDEBUG:f90wrap.fortran:type type_face defined in module module_structure\nDEBUG:f90wrap.transform:marking public symbol type_face\nDEBUG:f90wrap.transform:visiting Module(name=module_structure)\nDEBUG:f90wrap.transform:visiting Type(name=type_face)\nINFO:f90wrap.transform:adding missing constructor for type_face\nINFO:f90wrap.transform:adding missing destructor for type_face\nDEBUG:f90wrap.transform:visiting Module(name=module_structure)\nINFO:f90wrap.transform:visiting Module(name=module_structure) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=type_face)\nINFO:f90wrap.transform:visiting Type(name=type_face) found 1 constructors with names: ['type_face_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in type_face_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in type_face_finalise\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _type_bn_directmodule.c\nINFO:root:Generated Fortran support module: type_bn_direct_support.f90\nINFO:root:Generated minimal Python wrapper: type_bn_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": "fortran_compilation_failed",
      "notes": [
        "Using preprocessed files for f90wrap: ['type_bn.fpp']",
        "Command: f90wrap -m type_bn_direct /tmp/tmpwx_3665e/type_bn.fpp  --direct-c -v",
        "Generated C files: ['_type_bn_directmodule.c']",
        "Preprocessed type_bn.fpp -> type_bn_processed.f90",
        "Found support module: type_bn_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c type_bn_processed.f90 type_bn_direct_support.f90",
        "Fortran compilation failed: type_bn_direct_support.f90:55:15:\n\n   55 |         value = self%type_bn\n      |               1\nError: Syntax error in VALUE statement at (1)\ntype_bn_direct_support.f90:64:21:\n\n   64 |         self%type_bn = value\n      |                     1\nError: \u2018type_bn\u2019 at (1) is not a member of the \u2018type_face\u2019 structure; did you mean \u2018type\u2019?\n"
      ]
    },
    {
      "name": "type_check",
      "path": "/home/ert/code/f90wrap/examples/type_check",
      "status": "PASS",
      "f90wrap_output": "Kind map (also saved to .f2py_f2cmap)\n{}\n\nConstructors:\n['initialise_ptr', 'initialise', 'allocate']\n\nDestructors:\n['finalise', 'deallocate']\n\nShort names for derived types:\n{}\n\nString lengths:\n{}\n\nInitialisation lines for derived types\n{}\n\nPython module name remapping\n{}\nClass names remapping\n{}\n\nArgument name map:\n{}\n\nSize of Fortran derived type pointers is 4 bytes.\n\nParsing Fortran source files ['/tmp/tmp1y7jfb9i/main.fpp'] ...\nDEBUG:f90wrap.parser:processing file /tmp/tmp1y7jfb9i/main.fpp\nINFO:f90wrap.parser:marking module m_type_test as default private\nINFO:f90wrap.parser:parser reading type t_square\nDEBUG:f90wrap.parser:    type t_square\nINFO:f90wrap.parser:parser reading type t_circle\nDEBUG:f90wrap.parser:    type t_circle\nDEBUG:f90wrap.parser:    interface is_circle\nDEBUG:f90wrap.parser:    interface write_array\nDEBUG:f90wrap.parser:    interface optional_scalar\nDEBUG:f90wrap.parser:    interface in_scalar\nDEBUG:f90wrap.parser:    module subroutine checking is_circle_circle\nDEBUG:f90wrap.parser:    module subroutine is_circle_circle\nDEBUG:f90wrap.parser:    module subroutine checking is_circle_square\nDEBUG:f90wrap.parser:    module subroutine is_circle_square\nDEBUG:f90wrap.parser:    module subroutine checking write_array_int32_0d\nDEBUG:f90wrap.parser:    module subroutine write_array_int32_0d\nDEBUG:f90wrap.parser:    module subroutine checking write_array_int64_0d\nDEBUG:f90wrap.parser:    module subroutine write_array_int64_0d\nDEBUG:f90wrap.parser:    module subroutine checking write_array_real32_0d\nDEBUG:f90wrap.parser:    module subroutine write_array_real32_0d\nDEBUG:f90wrap.parser:    module subroutine checking write_array_real64_0d\nDEBUG:f90wrap.parser:    module subroutine write_array_real64_0d\nDEBUG:f90wrap.parser:    module subroutine checking write_array_int_1d\nDEBUG:f90wrap.parser:    module subroutine write_array_int_1d\nDEBUG:f90wrap.parser:    module subroutine checking write_array_int_2d\nDEBUG:f90wrap.parser:    module subroutine write_array_int_2d\nDEBUG:f90wrap.parser:    module subroutine checking write_array_real\nDEBUG:f90wrap.parser:    module subroutine write_array_real\nDEBUG:f90wrap.parser:    module subroutine checking write_array_double\nDEBUG:f90wrap.parser:    module subroutine write_array_double\nDEBUG:f90wrap.parser:    module subroutine checking write_array_bool\nDEBUG:f90wrap.parser:    module subroutine write_array_bool\nDEBUG:f90wrap.parser:    module subroutine checking optional_scalar_real\nDEBUG:f90wrap.parser:    module subroutine optional_scalar_real\nDEBUG:f90wrap.parser:    module subroutine checking optional_scalar_int\nDEBUG:f90wrap.parser:    module subroutine optional_scalar_int\nDEBUG:f90wrap.parser:    module function checking in_scalar_int8\nDEBUG:f90wrap.parser:        implicit type of \"in_scalar_int8\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_scalar_int8\nDEBUG:f90wrap.parser:    module function checking in_scalar_int16\nDEBUG:f90wrap.parser:        implicit type of \"in_scalar_int16\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_scalar_int16\nDEBUG:f90wrap.parser:    module function checking in_scalar_int32\nDEBUG:f90wrap.parser:        implicit type of \"in_scalar_int32\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_scalar_int32\nDEBUG:f90wrap.parser:    module function checking in_scalar_int64\nDEBUG:f90wrap.parser:        implicit type of \"in_scalar_int64\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_scalar_int64\nDEBUG:f90wrap.parser:    module function checking in_scalar_real32\nDEBUG:f90wrap.parser:        implicit type of \"in_scalar_real32\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_scalar_real32\nDEBUG:f90wrap.parser:    module function checking in_scalar_real64\nDEBUG:f90wrap.parser:        implicit type of \"in_scalar_real64\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_scalar_real64\nDEBUG:f90wrap.parser:    module function checking in_array_int64\nDEBUG:f90wrap.parser:        implicit type of \"in_array_int64\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_array_int64\nDEBUG:f90wrap.parser:    module function checking in_array_real64\nDEBUG:f90wrap.parser:        implicit type of \"in_array_real64\" inferred from its name as \"integer\"\nDEBUG:f90wrap.parser:    module function in_array_real64\nDEBUG:f90wrap.parser:  module m_type_test\ndone parsing source.\n\nDEBUG:f90wrap.fortran:type t_square defined in module m_type_test\nDEBUG:f90wrap.fortran:type t_circle defined in module m_type_test\nDerived types detected in Fortran source files:\n{'class(t_circle)': Type(name=t_circle),\n 'class(t_square)': Type(name=t_square),\n 't_circle': Type(name=t_circle),\n 't_square': Type(name=t_square),\n 'type(t_circle)': Type(name=t_circle),\n 'type(t_square)': Type(name=t_square)}\n\nClass name mapping:\n{'class(t_circle)': 't_circle',\n 'class(t_square)': 't_square',\n 't_circle': 't_circle',\n 't_square': 't_square',\n 'type(t_circle)': 't_circle',\n 'type(t_square)': 't_square'}\nModules for each type:\n{'m_type_test': 'm_type_test'}\nDEBUG:f90wrap.fortran:type t_square defined in module m_type_test\nDEBUG:f90wrap.fortran:type t_circle defined in module m_type_test\nDEBUG:f90wrap.transform:marking public symbol t_square\nDEBUG:f90wrap.transform:marking public symbol t_circle\nDEBUG:f90wrap.transform:marking private symbol write_array_int32_0d\nDEBUG:f90wrap.transform:marking private symbol write_array_bool\nDEBUG:f90wrap.transform:marking private symbol write_array_real32_0d\nDEBUG:f90wrap.transform:marking private symbol write_array_int_2d\nDEBUG:f90wrap.transform:marking private symbol optional_scalar_real\nDEBUG:f90wrap.transform:marking private symbol optional_scalar_int\nINFO:f90wrap.transform:setting call_name of is_circle_circle to is_circle\nINFO:f90wrap.transform:setting call_name of is_circle_square to is_circle\nINFO:f90wrap.transform:setting call_name of write_array_double to write_array\nINFO:f90wrap.transform:setting call_name of write_array_real to write_array\nINFO:f90wrap.transform:setting call_name of write_array_int64_0d to write_array\nINFO:f90wrap.transform:setting call_name of write_array_int32_0d to write_array\nINFO:f90wrap.transform:setting call_name of write_array_bool to write_array\nINFO:f90wrap.transform:setting call_name of write_array_real64_0d to write_array\nINFO:f90wrap.transform:setting call_name of write_array_int_1d to write_array\nINFO:f90wrap.transform:setting call_name of write_array_real32_0d to write_array\nINFO:f90wrap.transform:setting call_name of write_array_int_2d to write_array\nINFO:f90wrap.transform:setting call_name of optional_scalar_real to optional_scalar\nINFO:f90wrap.transform:setting call_name of optional_scalar_int to optional_scalar\nINFO:f90wrap.transform:setting call_name of in_array_int64 to in_scalar\nINFO:f90wrap.transform:setting call_name of in_scalar_int16 to in_scalar\nINFO:f90wrap.transform:setting call_name of in_scalar_real32 to in_scalar\nINFO:f90wrap.transform:setting call_name of in_scalar_real64 to in_scalar\nINFO:f90wrap.transform:setting call_name of in_scalar_int32 to in_scalar\nINFO:f90wrap.transform:setting call_name of in_scalar_int64 to in_scalar\nINFO:f90wrap.transform:setting call_name of in_array_real64 to in_scalar\nINFO:f90wrap.transform:setting call_name of in_scalar_int8 to in_scalar\nDEBUG:f90wrap.transform:visiting Module(name=m_type_test)\nDEBUG:f90wrap.transform:visiting Type(name=t_square)\nDEBUG:f90wrap.transform:visiting Type(name=t_circle)\nINFO:f90wrap.transform:adding missing constructor for t_square\nINFO:f90wrap.transform:adding missing constructor for t_circle\nINFO:f90wrap.transform:adding missing destructor for t_square\nINFO:f90wrap.transform:adding missing destructor for t_circle\nDEBUG:f90wrap.transform:visiting Module(name=m_type_test)\nINFO:f90wrap.transform:visiting Module(name=m_type_test) found 0 constructors with names: []\nDEBUG:f90wrap.transform:visiting Type(name=t_square)\nINFO:f90wrap.transform:visiting Type(name=t_square) found 1 constructors with names: ['t_square_initialise']\nDEBUG:f90wrap.transform:visiting Type(name=t_circle)\nINFO:f90wrap.transform:visiting Type(name=t_circle) found 1 constructors with names: ['t_circle_initialise']\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_square_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_square_finalise\nDEBUG:f90wrap.transform:allocating arg \"this\" in t_circle_initialise\nDEBUG:f90wrap.transform:deallocating arg \"this\" in t_circle_finalise\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to is_circle_circle\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to is_circle_square\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to write_array_double\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to write_array_real\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to write_array_bool\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to write_array_int_1d\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0), Argument(name=f90wrap_n1)] to write_array_int_2d\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to optional_scalar_real\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to optional_scalar_int\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to in_array_int64\nDEBUG:f90wrap.transform:adding dummy arguments [Argument(name=f90wrap_n0)] to in_array_real64\nINFO:root:Using direct C generation mode (bypassing f2py)\nINFO:root:Generated C extension module: _type_check_directmodule.c\nINFO:root:Generated Fortran support module: type_check_direct_support.f90\nINFO:root:Generated minimal Python wrapper: type_check_direct.py\nINFO:root:Direct C generation complete!\nINFO:root:To compile: python setup.py build_ext --inplace\n",
      "f90wrap_error": "",
      "test_output": "",
      "test_error": "",
      "error_category": null,
      "notes": [
        "Using preprocessed files for f90wrap: ['main.fpp']",
        "Command: f90wrap -m type_check_direct /tmp/tmp1y7jfb9i/main.fpp  --direct-c -v",
        "Generated C files: ['_type_check_directmodule.c']",
        "Preprocessed main.fpp -> main_processed.f90",
        "Found support module: type_check_direct_support.f90",
        "Compiling Fortran: gfortran -fPIC -c main_processed.f90 type_check_direct_support.f90",
        "Fortran compilation successful",
        "Compiling C: gcc -fPIC -c _type_check_directmodule.c  -I/home/ert/code/f90wrap/f90wrap -I/usr/include/python3.13 -I/home/ert/code/.venv/lib/python3.13/site-packages/numpy/_core/include -o _type_check_directmodule.o",
        "Linking: gcc -shared _type_check_directmodule.o type_check_direct_support.o main_processed.o -lgfortran -o _type_check_direct.so",
        "No tests.py found, but compilation succeeded"
      ]
    }
  ]
}